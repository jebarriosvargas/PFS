{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Celda primitiva\n",
        "\n",
        "::: {.callout-note appearance=\"simple\" icon=false collapse=\"false\"}\n",
        "## Celda primitiva (definición)\n",
        "Es la celda unitaria que contiene un punto de la red.\n",
        ":::\n",
        "\n",
        "Hay dos formas de identificar la celda primitiva.\n",
        "\n",
        "::: {.callout-tip appearance=\"simple\" icon=false collapse=\"false\"}\n",
        "## A partir de los vectores de red\n",
        ":::{.justify}\n",
        "En 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. \n",
        "En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n",
        ":::\n",
        ":::\n"
      ],
      "id": "4ae36883"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-celdas2d1\n",
        "#| fig-cap: Ejemplo de red bidimensional\n",
        "\n",
        "from pylab import *\n",
        "\n",
        "def GraficadeRedCell(vec_a1,vec_a2,polyx,polyy):\n",
        "    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n",
        "    n1 = n1.flatten()\n",
        "    n2 = n2.flatten()\n",
        "    A = array( [vec_a1,vec_a2] )\n",
        "    coefs = column_stack((n1,n2))\n",
        "    red = dot( coefs,A )\n",
        "\n",
        "    a1 = sqrt(dot(vec_a1,vec_a1))\n",
        "    a2 = sqrt(dot(vec_a2,vec_a2))\n",
        "\n",
        "    fig,ax = plt.subplots(figsize=((6,6)))\n",
        "    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n",
        "    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n",
        "    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n",
        "\n",
        "\n",
        "    ax.fill(polyx,polyy,alpha=0.5,color=\"#50c878\")\n",
        "\n",
        "    ax.legend()\n",
        "    ax.set_xlim(-6.4,6.4)\n",
        "    ax.set_ylim(-3.4,3.4)\n",
        "    ax.set_aspect('equal')\n",
        "    plt.show()\n",
        "    return \n",
        "\n",
        "a1 = 1.0\n",
        "a2 = 1.0\n",
        "vec_a1 = array([       a1,         0])\n",
        "θ = radians(60)\n",
        "vec_a2 = array([a2*cos(θ), a2*sin(θ)])\n",
        "\n",
        "polyx = [0,vec_a1[0],vec_a1[0]+vec_a2[0],vec_a2[0],0]\n",
        "polyy = [0,vec_a1[1],vec_a1[1]+vec_a2[1],vec_a2[1],0]\n",
        "\n",
        "GraficadeRedCell(vec_a1,vec_a2,polyx,polyy)"
      ],
      "id": "fig-celdas2d1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-tip appearance=\"simple\" icon=false collapse=\"false\"}\n",
        "## Construcción de Wigner-Seitz\n",
        ":::{.justify}\n",
        "En 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz.\n",
        "En 3D, también, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza un plano perpendicular a cada segmento que pase por el punto medio. El volumen más pequeño encerrado por los planos es la celda primitiva de Wigner-Seitz.\n",
        ":::\n",
        ":::\n"
      ],
      "id": "3eca9eb5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-celdas2d2\n",
        "#| fig-cap: Ejemplo de red bidimensional\n",
        "\n",
        "def FindInterection2D(v,w):\n",
        "    AA = np.array([v[0:2],w[0:2]])\n",
        "    bb = 0.5*np.array( [np.dot(v,v),np.dot(w,w)] )\n",
        "    return np.linalg.solve(AA, bb)\n",
        "\n",
        "def BuildWignerSeitz(vec_a1,vec_a2):\n",
        "    puntosall = []\n",
        "    for n in arange(-1,2):\n",
        "        for m in arange(-1,2):\n",
        "            w = n*vec_a1+m*vec_a2\n",
        "            if (m!=0):\n",
        "                xp = FindInterection2D( vec_a1,w)\n",
        "                xn = FindInterection2D(-vec_a1,w)\n",
        "            if (n!=0):\n",
        "                yp = FindInterection2D( vec_a2,w)\n",
        "                yn = FindInterection2D(-vec_a2,w)\n",
        "            puntosall.append(xp)\n",
        "            puntosall.append(yp)\n",
        "            puntosall.append(xn)\n",
        "            puntosall.append(yn)\n",
        "    puntosall = array(puntosall).T\n",
        "\n",
        "    # Selecciona sólo los que están a la mínima distancia\n",
        "    dist    = sum(puntosall.T*puntosall.T,axis=1)\n",
        "    mindist = min(dist)\n",
        "    ϵ       = 1e-4\n",
        "    logical = dist<(mindist+ϵ)\n",
        "    WignerSeitz = puntosall[:,logical]\n",
        "\n",
        "    # Quita los puntos repetidos (sólo funciona en 2D)\n",
        "    n   = 0\n",
        "    z   = WignerSeitz[0]+WignerSeitz[1]*1J\n",
        "    ang = angle(z)\n",
        "    while (n<len(z)):\n",
        "        l_ind    = ones(len(z),dtype=bool)\n",
        "        l_ind[n] = False\n",
        "        \n",
        "        arrlog = logical_and( abs(ang-ang[n])<ϵ, l_ind)\n",
        "\n",
        "        arrlog = array( arrlog==False)\n",
        "\n",
        "        z   = array(z[arrlog])\n",
        "        ang = angle(z)\n",
        "        n += 1\n",
        "        \n",
        "    indSort = argsort(ang)\n",
        "\n",
        "    WignerSeitz = array([real(z[indSort]),imag(z[indSort])])\n",
        "    return WignerSeitz\n",
        "\n",
        "a1 = 1.0\n",
        "a2 = 1.0\n",
        "vec_a1 = array([       a1,         0])\n",
        "θ = radians(60)\n",
        "vec_a2 = array([a2*cos(θ), a2*sin(θ)])\n",
        "\n",
        "WignerSeitz = BuildWignerSeitz(vec_a1,vec_a2)\n",
        "\n",
        "GraficadeRedCell(vec_a1,vec_a2,WignerSeitz[0],WignerSeitz[1])"
      ],
      "id": "fig-celdas2d2",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}