[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PFS",
    "section": "",
    "text": "En el sitio se encuentran una selección de notas del curso de Propiedades de Física de los Sólidos (clave: 0087) de la Facultad de Química, UNAM."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "2  Acerca de",
    "section": "",
    "text": "Acerca del sitio"
  },
  {
    "objectID": "vibra1d.html",
    "href": "vibra1d.html",
    "title": "4  Cadena Unidimensional",
    "section": "",
    "text": "from pylab import *\n\nt   = 0; κ = 1; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk1   = 0.2*pi/a\nk2   = 0.5*pi/a+2*pi/a\n#######\nω1   = sqrt(4*κ/m) * abs( sin(k1*a/2) )\nω2   = sqrt(4*κ/m) * abs( sin(k2*a/2) )\nu1   = A*exp(1J*ω1*t-1J*k1*n*a) # En lugar de δx_n\nu2   = A*exp(1J*ω2*t-1J*k2*n*a) # En lugar de δx_n\ny1   = zeros(len(xeq)) + u1\ny2   = zeros(len(xeq)) + u2\nx    = xeq # + u # δx\nprint(f\"k = {k1:.3f}, {k2:.3f}\")\nprint(f\"ω = {ω1:.3f}, {ω2:.3f}\")\n\nk = 0.628, 7.854\nω = 0.618, 1.414\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω1 # periodo\nveces  = 4       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nx0  = xeq\nu10 = A*exp(1J*ω1*t0-1J*k1*n*a)\ny10 = zeros(len(xeq)) + u10\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    u1 = A*exp(1J*ω1*t-1J*k1*n*a)\n    u2 = A*exp(1J*ω2*t-1J*k2*n*a)\n    y1 = zeros(len(xeq)) + u1\n    y2 = zeros(len(xeq)) + u2\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x,\n                                              y=y1.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0, \n                       y=y10.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=5,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  },
  {
    "objectID": "pyscf_H2.html",
    "href": "pyscf_H2.html",
    "title": "3  Molécula \\(H_2\\)",
    "section": "",
    "text": "# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n4 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n5 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n6 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "pyscf_H2.html#variación-de-la-geometría",
    "href": "pyscf_H2.html#variación-de-la-geometría",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.2 Variación de la geometría",
    "text": "3.2 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "pyscf_H2.html#función-que-devuelve-la-energía",
    "href": "pyscf_H2.html#función-que-devuelve-la-energía",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.3 Función que devuelve la energía",
    "text": "3.3 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "molecula_H2.html",
    "href": "molecula_H2.html",
    "title": "Molécula \\(H_2\\)",
    "section": "",
    "text": "# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n2 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n3 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')\n\n\n\n\n\n\nSource: Abrir en colab"
  },
  {
    "objectID": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "Molécula \\(H_2\\)",
    "section": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "molecula_H2.html#variación-de-la-geometría",
    "href": "molecula_H2.html#variación-de-la-geometría",
    "title": "Molécula \\(H_2\\)",
    "section": "1.1 Variación de la geometría",
    "text": "1.1 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "molecula_H2.html#función-que-devuelve-la-energía",
    "href": "molecula_H2.html#función-que-devuelve-la-energía",
    "title": "Molécula \\(H_2\\)",
    "section": "1.2 Función que devuelve la energía",
    "text": "1.2 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "eqnonda.html",
    "href": "eqnonda.html",
    "title": "5  Ecuación de onda",
    "section": "",
    "text": "La ecuación de onda es una ecuación diferencial parcial de segundo orden lineal y tiene la forma siguiente,\n\\[\n\\definecolor{purpura}{RGB}{160, 32, 240}\n\\newcommand{\\uu}{\\textcolor{purpura}{u}}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\nabla^2 \\uu\n\\tag{5.1}\\]\ndonde \\(v\\) es la rapidez de la onda y \\(\\uu\\) es una función de la posición y el tiempo, \\(\\uu = \\uu(\\vec{r},t)\\).\n\n\n\n\n\n\nEcuaciones de Maxwell\n\n\n\n\n\nEl campo eléctrico y el campo magnético siguen una ecuación de onda en el caso de que no haya cargas ni corrientes en el espacio\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{E} = c^2 \\nabla^2 \\vec{E} \\\\\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{B} = c^2 \\nabla^2 \\vec{B}\n\\]\n\n\n\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\tag{5.2}\\]\nConsideremos al espacio de forma discreta en el espacio\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h} \\approx \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h}\n\\]\nAlternativamente\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h} \\approx \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h}\n\\]\nEntonces la segunda derivada,\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} =\\lim_{h\\to 0} \\frac{\\frac{\\partial \\uu}{\\partial x}|_{x_0+h/2} - \\frac{\\partial \\uu}{\\partial x}|_{x_0-h/2} }{h}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} \\approx \\frac{u(x_0-h,t)-2u(x_0,t)+u(x_0+h,t)}{h}\n\\]"
  },
  {
    "objectID": "eqnonda.html#ejemplo",
    "href": "eqnonda.html#ejemplo",
    "title": "5  Ecuación de onda",
    "section": "5.1 Ejemplo",
    "text": "5.1 Ejemplo\nPosiblemente reconozca\n:::\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\begin{align}\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\end{align}\n\\tag{5.2}\\]"
  },
  {
    "objectID": "vibra1d.html#relación-de-dispersión",
    "href": "vibra1d.html#relación-de-dispersión",
    "title": "4  Cadena Unidimensional",
    "section": "4.1 Relación de dispersión",
    "text": "4.1 Relación de dispersión\n\\[\n\\definecolor{azul}{RGB}{0, 0, 139}\n\\newcommand{\\kk}{\\textcolor{red}{k}}\n\\]\n\\[\n\\omega^2 = 2\\frac{\\kappa }{m}\\bigg[  1-\\cos(\\kk a ) \\bigg]\n\\]\nEntonces, \\[\n\\omega(k) = \\sqrt{\\frac{4\\kappa}{m}} \\bigg| \\sin\\bigg( \\frac{\\kk a}{2} \\bigg) \\bigg|\n\\]"
  },
  {
    "objectID": "vibra1d.html#desplazamientos-del-equilibrio",
    "href": "vibra1d.html#desplazamientos-del-equilibrio",
    "title": "4  Cadena Unidimensional",
    "section": "4.2 Desplazamientos del equilibrio",
    "text": "4.2 Desplazamientos del equilibrio\n\\[\nx_n = x_n^{\\rm eq} + A e^{i\\omega t-i\\kk x_n^{\\rm eq}}\n\\]\ndonde \\(x_n^{\\rm eq}=na\\).\n\\[\n\\delta x_n = A e^{i\\omega t-i\\kk na}\n\\]\n\nfrom pylab import *\n\nt   = 0; κ = 100; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = 0.2*pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\nValor de k seleccionado: \nk = 0.628\nValor de ω seleccionado: \nω = 6.180\nPeriódo de oscilación: \nT = 6.180\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  },
  {
    "objectID": "matrizdinamica.html",
    "href": "matrizdinamica.html",
    "title": "6  Matriz dinámica",
    "section": "",
    "text": "Objetivo: describir de forma general cómo se mueven los átomos en un sólido\nLa estrategía general es: determinar la energía potencial, derivar las ecuaciones de movimiento y resolver las ecuaciones de movimiento buscando los modos normales.\nLa energía potencial\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ u_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#la-energía-potencial",
    "href": "matrizdinamica.html#la-energía-potencial",
    "title": "6  Matriz dinámica",
    "section": "6.1 La energía potencial",
    "text": "6.1 La energía potencial\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\vk}{\\vec{k}}\n\\newcommand{\\vRn}{\\vec{R}_{\\vn}}\n\\newcommand{\\vRm}{\\vec{R}_{\\vm}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ \\delta r_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}} = \\sum_{\\vm \\beta j} -U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#ecuaciones-de-movimiento",
    "href": "matrizdinamica.html#ecuaciones-de-movimiento",
    "title": "6  Matriz dinámica",
    "section": "6.2 Ecuaciones de movimiento",
    "text": "6.2 Ecuaciones de movimiento\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} = -\\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j} = 0\n\\]\nNotamos que tenemos \\(3rN\\) ecuaciones de movimiento, donde el \\(3\\) corresponde a las tres direcciones de movimiento en el espacio, \\(r\\) es el número de átomos en la celda unitaria y \\(N\\) son el número de celdas unitarias.\nProponemos una solución correspondiente a un modo normal, \\[\n\\udes{\\vn}{\\alpha}{i} = e^{i\\omega t-i\\vk\\cdot \\vRn }\\bigg[  \\frac{1}{\\sqrt{M}_\\alpha} u_{\\alpha i} \\bigg]\n\\]\nSustituimos en las ecuaciones de movimiento, \\[\n-\\omega^2 M_\\alpha \\bigg[  \\frac{1}{\\sqrt{M_\\alpha}} u_{\\alpha i} \\bigg] + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) } \\frac{1}{\\sqrt{M}_\\beta} u_{\\beta j} = 0\n\\]\n\\[\n-\\omega^2 \\sqrt{M}_\\alpha u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M}_\\beta}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\nNotamos que las ecuaciones anteriores son \\(3r\\) para cada celda unitaria \\(\\vn\\) y dado que todas las celdas son iguales, podemos elegir arbitrariamente \\(\\vn=\\vec{0}\\) y resolver. Entonces, dichas soluciones serán las mismas para todas.\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm }  \\bigg] u_{\\beta j} =0\n\\]\nLas \\(3r\\) ecuaciones podemos reescribirlas de forma matricial de la forma, \\[\n\\omega^2\\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right] =\n\\bigg[ \\frac{1}{\\sqrt{M_\\beta M_\\alpha}} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm } \\bigg]_{\\alpha i,\\beta j} \\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right]\n\\]\ndonde la matriz del lado derecho se llama matriz dinámica."
  },
  {
    "objectID": "matrizdinamica.html#otra-notación",
    "href": "matrizdinamica.html#otra-notación",
    "title": "6  Matriz dinámica",
    "section": "6.3 Otra notación",
    "text": "6.3 Otra notación\nAlternativamente,\n\\[\n\\sum_{\\beta j } -\\omega^2 \\delta_{\\alpha \\beta}\\delta_{ij} u_{\\beta j}+ \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]"
  }
]