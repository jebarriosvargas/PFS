[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Propiedades Físicas de los Sólidos",
    "section": "",
    "text": "Prefacio\nEn el sitio se encuentran una selección de notas del curso de Propiedades de Física de los Sólidos (clave: 0087) de la Facultad de Química, UNAM."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "2  Acerca de",
    "section": "",
    "text": "Acerca del sitio"
  },
  {
    "objectID": "vibra1d.html",
    "href": "vibra1d.html",
    "title": "4  Cadena Unidimensional",
    "section": "",
    "text": "from pylab import *\n\nt   = 0; κ = 1; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk1   = 0.2*pi/a\nk2   = 0.5*pi/a+2*pi/a\n#######\nω1   = sqrt(4*κ/m) * abs( sin(k1*a/2) )\nω2   = sqrt(4*κ/m) * abs( sin(k2*a/2) )\nu1   = A*exp(1J*ω1*t-1J*k1*n*a) # En lugar de δx_n\nu2   = A*exp(1J*ω2*t-1J*k2*n*a) # En lugar de δx_n\ny1   = zeros(len(xeq)) + u1\ny2   = zeros(len(xeq)) + u2\nx    = xeq # + u # δx\nprint(f\"k = {k1:.3f}, {k2:.3f}\")\nprint(f\"ω = {ω1:.3f}, {ω2:.3f}\")\n\nk = 0.628, 7.854\nω = 0.618, 1.414\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω1 # periodo\nveces  = 4       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nx0  = xeq\nu10 = A*exp(1J*ω1*t0-1J*k1*n*a)\ny10 = zeros(len(xeq)) + u10\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    u1 = A*exp(1J*ω1*t-1J*k1*n*a)\n    u2 = A*exp(1J*ω2*t-1J*k2*n*a)\n    y1 = zeros(len(xeq)) + u1\n    y2 = zeros(len(xeq)) + u2\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x,\n                                              y=y1.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0, \n                       y=y10.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=5,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  },
  {
    "objectID": "pyscf_H2.html",
    "href": "pyscf_H2.html",
    "title": "3  Molécula \\(H_2\\)",
    "section": "",
    "text": "# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n4 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n5 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n6 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "pyscf_H2.html#variación-de-la-geometría",
    "href": "pyscf_H2.html#variación-de-la-geometría",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.2 Variación de la geometría",
    "text": "3.2 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "pyscf_H2.html#función-que-devuelve-la-energía",
    "href": "pyscf_H2.html#función-que-devuelve-la-energía",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.3 Función que devuelve la energía",
    "text": "3.3 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "molecula_H2.html",
    "href": "molecula_H2.html",
    "title": "Molécula \\(H_2\\)",
    "section": "",
    "text": "Code\n# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n\n1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n\nCode\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n\n\nCode\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n2 Variación de la geometría\n\n\nCode\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n3 Función que devuelve la energía\n\n\nCode\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n\n\nCode\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n\n\nCode\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\n\n\nCode\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\n\nText(0, 0.5, 'E [Ha]')\n\n\n\n\n\n\nSource: Abrir en colab"
  },
  {
    "objectID": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "Molécula \\(H_2\\)",
    "section": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "molecula_H2.html#variación-de-la-geometría",
    "href": "molecula_H2.html#variación-de-la-geometría",
    "title": "Molécula \\(H_2\\)",
    "section": "1.1 Variación de la geometría",
    "text": "1.1 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "molecula_H2.html#función-que-devuelve-la-energía",
    "href": "molecula_H2.html#función-que-devuelve-la-energía",
    "title": "Molécula \\(H_2\\)",
    "section": "1.2 Función que devuelve la energía",
    "text": "1.2 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "eqnonda.html",
    "href": "eqnonda.html",
    "title": "5  Ecuación de onda",
    "section": "",
    "text": "La ecuación de onda es una ecuación diferencial parcial de segundo orden lineal y tiene la forma siguiente,\n\\[\n\\definecolor{purpura}{RGB}{160, 32, 240}\n\\newcommand{\\uu}{\\textcolor{purpura}{u}}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\nabla^2 \\uu\n\\tag{5.1}\\]\ndonde \\(v\\) es la rapidez de la onda y \\(\\uu\\) es una función de la posición y el tiempo, \\(\\uu = \\uu(\\vec{r},t)\\).\n\n\n\n\n\n\nEcuaciones de Maxwell\n\n\n\n\n\nEl campo eléctrico y el campo magnético siguen una ecuación de onda en el caso de que no haya cargas ni corrientes en el espacio\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{E} = c^2 \\nabla^2 \\vec{E} \\\\\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{B} = c^2 \\nabla^2 \\vec{B}\n\\]\n\n\n\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\tag{5.2}\\]\nConsideremos al espacio de forma discreta en el espacio\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h} \\approx \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h}\n\\]\nAlternativamente\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h} \\approx \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h}\n\\]\nEntonces la segunda derivada,\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} =\\lim_{h\\to 0} \\frac{\\frac{\\partial \\uu}{\\partial x}|_{x_0+h/2} - \\frac{\\partial \\uu}{\\partial x}|_{x_0-h/2} }{h}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} \\approx \\frac{u(x_0-h,t)-2u(x_0,t)+u(x_0+h,t)}{h}\n\\]"
  },
  {
    "objectID": "eqnonda.html#ejemplo",
    "href": "eqnonda.html#ejemplo",
    "title": "5  Ecuación de onda",
    "section": "5.1 Ejemplo",
    "text": "5.1 Ejemplo\nPosiblemente reconozca\n:::\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\begin{align}\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\end{align}\n\\tag{5.2}\\]"
  },
  {
    "objectID": "vibra1d.html#relación-de-dispersión",
    "href": "vibra1d.html#relación-de-dispersión",
    "title": "4  Cadena Unidimensional",
    "section": "4.1 Relación de dispersión",
    "text": "4.1 Relación de dispersión\n\\[\n\\definecolor{azul}{RGB}{0, 0, 139}\n\\newcommand{\\kk}{\\textcolor{red}{k}}\n\\]\n\\[\n\\omega^2 = 2\\frac{\\kappa }{m}\\bigg[  1-\\cos(\\kk a ) \\bigg]\n\\]\nEntonces, \\[\n\\omega(k) = \\sqrt{\\frac{4\\kappa}{m}} \\bigg| \\sin\\bigg( \\frac{\\kk a}{2} \\bigg) \\bigg|\n\\]"
  },
  {
    "objectID": "vibra1d.html#desplazamientos-del-equilibrio",
    "href": "vibra1d.html#desplazamientos-del-equilibrio",
    "title": "4  Cadena Unidimensional",
    "section": "4.2 Desplazamientos del equilibrio",
    "text": "4.2 Desplazamientos del equilibrio\n\\[\nx_n = x_n^{\\rm eq} + A e^{i\\omega t-i\\kk x_n^{\\rm eq}}\n\\]\ndonde \\(x_n^{\\rm eq}=na\\).\n\\[\n\\delta x_n = A e^{i\\omega t-i\\kk na}\n\\]\n\nfrom pylab import *\n\nt   = 0; κ = 100; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = 0.2*pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\nValor de k seleccionado: \nk = 0.628\nValor de ω seleccionado: \nω = 6.180\nPeriódo de oscilación: \nT = 6.180\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  },
  {
    "objectID": "matrizdinamica.html",
    "href": "matrizdinamica.html",
    "title": "6  Matriz dinámica",
    "section": "",
    "text": "Objetivo: describir de forma general cómo se mueven los átomos en un sólido\nLa estrategía general es: determinar la energía potencial, derivar las ecuaciones de movimiento y resolver las ecuaciones de movimiento buscando los modos normales.\nLa energía potencial\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ u_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#la-energía-potencial",
    "href": "matrizdinamica.html#la-energía-potencial",
    "title": "6  Matriz dinámica",
    "section": "6.1 La energía potencial",
    "text": "6.1 La energía potencial\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\vk}{\\vec{k}}\n\\newcommand{\\vRn}{\\vec{R}_{\\vn}}\n\\newcommand{\\vRm}{\\vec{R}_{\\vm}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ \\delta r_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}} = \\sum_{\\vm \\beta j} -U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#ecuaciones-de-movimiento",
    "href": "matrizdinamica.html#ecuaciones-de-movimiento",
    "title": "6  Matriz dinámica",
    "section": "6.2 Ecuaciones de movimiento",
    "text": "6.2 Ecuaciones de movimiento\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} = -\\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j} = 0\n\\]\nNotamos que tenemos \\(3rN\\) ecuaciones de movimiento, donde el \\(3\\) corresponde a las tres direcciones de movimiento en el espacio, \\(r\\) es el número de átomos en la celda unitaria y \\(N\\) son el número de celdas unitarias.\nProponemos una solución correspondiente a un modo normal, \\[\n\\udes{\\vn}{\\alpha}{i} = e^{i\\omega t-i\\vk\\cdot \\vRn }\\bigg[  \\frac{1}{\\sqrt{M}_\\alpha} u_{\\alpha i} \\bigg]\n\\]\nSustituimos en las ecuaciones de movimiento, \\[\n-\\omega^2 M_\\alpha \\bigg[  \\frac{1}{\\sqrt{M_\\alpha}} u_{\\alpha i} \\bigg] + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) } \\frac{1}{\\sqrt{M}_\\beta} u_{\\beta j} = 0\n\\]\n\\[\n-\\omega^2 \\sqrt{M}_\\alpha u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M}_\\beta}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\nNotamos que las ecuaciones anteriores son \\(3r\\) para cada celda unitaria \\(\\vn\\) y dado que todas las celdas son iguales, podemos elegir arbitrariamente \\(\\vn=\\vec{0}\\) y resolver. Entonces, dichas soluciones serán las mismas para todas.\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm }  \\bigg] u_{\\beta j} =0\n\\]\nLas \\(3r\\) ecuaciones podemos reescribirlas de forma matricial de la forma, \\[\n\\omega^2\\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right] =\n\\bigg[ \\frac{1}{\\sqrt{M_\\beta M_\\alpha}} \\sum_{\\vm} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm } \\bigg]_{\\alpha i,\\beta j} \\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right]\n\\]\ndonde la matriz del lado derecho se llama matriz dinámica.\n\\[\nD = \\left[\\begin{array}{cccc}\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\\ldots \\\\\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\n\\ldots \\\\\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\n\\ldots \\\\\n\\vdots&\\vdots&\\vdots&\\vdots\n\\end{array}\\right]\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#otra-notación",
    "href": "matrizdinamica.html#otra-notación",
    "title": "6  Matriz dinámica",
    "section": "6.3 Otra notación",
    "text": "6.3 Otra notación\nAlternativamente,\n\\[\n\\sum_{\\beta j } -\\omega^2 \\delta_{\\alpha \\beta}\\delta_{ij} u_{\\beta j}+ \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]"
  },
  {
    "objectID": "calorespecifico.html",
    "href": "calorespecifico.html",
    "title": "7  Calor específico de los sólidos",
    "section": "",
    "text": "En 1819 Pierre Louis Dulong y Alexis Thérèse Petit establecieron que para casi todos los sólidos la capacidad calorífica esta dada por (ley de la Doulong-Petit),\n\\[\nC= 3 k_{\\rm B} \\text{ por átomo}\n\\]\n\\[\nC =3R\n\\]\ndonde \\(k_{\\rm B}=1.380649\\times 10^{-23} {\\rm J}\\cdot {\\rm K}^{-1}\\) es la constante de Boltzmann y \\(R=8.31446261815324 {\\rm J}\\cdot {\\rm K}^{-1}\\cdot {\\rm mol}^{-1}\\) es la constante molar de los gases.\nLa ly de Doulong-Petit es válida para temperatura ambiente.\n\n\n\nMaterial\nC/R\n\n\n\n\nAluminio (Al)\n2.91\n\n\nAntimonio (Sb)\n3.03\n\n\nCobre (Cu)\n2.94\n\n\nOro (Au)\n3.05\n\n\nPlata (Ag)\n2.99\n\n\nDiamante (C)\n0.735\n\n\n\nEn 1896 Boltzmann intento dar sentido a la Ley de Doulong Petit. Planteó, cada átomo del sólido esta ligado a otros átomos entonces cada átomo es un oscilador armónico. Es decir, su energía esta dada por \\(mv^2/2+kx^2/2\\) y utilizando el Teorema de equipartición de la energía, estableció que cada grado de libertad de oscilación contribuye en \\(k_{\\rm B}T\\) a la energía del sistema. En el caso de sólidos en tres dimensiones cada átomo contribuye a la energía en \\(3k_{\\rm B}T\\) por lo que\n\\[\nC=\\frac{d U}{d T } =3k_{\\rm B} \\text{ por átomo}\n\\]\n\n\nEn el caso de un gas, cada átomo contribuye a la energía en \\(mv_x^2/2+mv_y^2/2+mv_z^2/2\\) por lo que siguiendo el Teorema de Equipartición de la energía la capacidad calorífica por átomo es \\(C=3k_{\\rm B}/2\\).\nEn los inicios de los 1900, empezaron a realizar experimentos a bajas temperatura a algunos Kelvin. En 1907, Einstein intento explicar la capacidad calorífica a bajas temperaturas. Supuso que cada átomo es un oscilador armónico cuántico \\(E_n=\\hbar \\omega (n+1/2)\\).\nBoltzmann ya había establecido que la probabilidad de encontrar a un sistema a una energía \\(E_i\\) era \\[\n\\text{Probabilidad }\\propto e^{-\\beta E_i}=e^{-E_i/k_{\\rm B}T}\n\\]\nIntroduciendo la función de partición,\n\\[\nZ_{\\rm 1D} = \\sum_{n\\geq 0}  e^{-\\beta \\hbar \\omega (n+1/2)} = \\frac{e^{-\\beta \\hbar \\omega/2}}{1-e^{-\\beta \\hbar \\omega/2}}=\\frac{1}{2\\sinh (\\beta\\hbar\\omega/2)}\n\\]\n\n\nRecordemos que \\[\n\\sinh x=\\frac{e^x-e^{-x}}{2}\n\\]\npodemos calcular el valor medio de la energía\n\\[\n\\langle E \\rangle = -\\frac{1}{Z_{1D}} \\frac{\\partial Z_{1D}}{\\partial \\beta} =\\frac{\\hbar \\omega}{2} \\coth(\\beta \\hbar \\omega/2) = \\hbar \\omega \\bigg[ n_{\\rm B}(\\beta \\hbar \\omega) +\\frac{1}{2} \\bigg]\n\\]\ndonde \\[\nn_{\\rm B}(x)=\\frac{1}{e^x-1}\n\\]\nEntonces,\n\\[\nC = \\frac{\\partial \\langle E \\rangle}{\\partial T} = k_{\\rm B} (\\beta \\hbar \\omega)^2 \\frac{e^{\\beta \\omega}}{(e^{\\beta \\hbar \\omega}-1)^2}\n\\]\nEn el límite \\(T\\to \\infty\\)\n\\[\nC=k_{\\rm B} \\; \\Rightarrow \\; \\text{En tres dimensiones } C=3k_{\\rm B}\n\\]\nAún existía la problemática de bajas temperaturas el modelo de Einstein establece que \\(C\\sim e^{k_{\\rm B}T}\\) y experimentalmente se tenía que \\(C\\sim T^3\\).\nEn 1912, Debye desarrolla un modelo para determinar la cpacidad calorífica a bajas temperaturas. Las oscilaciones (osciladores armónicos) son similares a las del sonido (ondas sonoras). En las ondas sonoras \\[\n\\omega (k) = v| k|\n\\]\ndonde \\(v\\) es la rapidez del sonido.\nAnálogo a Einstein\n\\[\n\\langle E\\rangle = 3 \\sum_{\\vec{k}} \\hbar \\omega (\\vec{k}) \\bigg[ n_{\\rm B}(\\beta \\hbar \\omega) +1/2 \\bigg]\n\\]\nSustituimos que \\(\\omega (\\vec{k})=vk\\) y \\[\n\\sum_{k_x} \\to \\frac{L}{2\\pi} \\int dk_x\n\\]\n\\[\n\\langle E\\rangle = 3\\frac{L^3}{(2\\pi)^3} \\int d\\vec{k} \\Bigg\\{ \\hbar\\omega(\\vec{k}) \\bigg[  n_{\\rm B}(\\beta \\hbar \\omega) +1/2 \\bigg] \\Bigg\\}\n\\]\n\\[\n\\int d\\vec{k} \\to 4\\pi \\int_0^{\\infty} k^2 dk\n\\]\nUtilizando que \\(k=\\omega/v\\) entonces $dk=d$\n\\[\n\\langle E \\rangle = 3\\bigg(  \\frac{4\\pi L^3}{(2\\pi)^3} \\bigg) \\int_0^{\\omega_{\\rm corte}=\\omega_{\\rm D}} d\\omega \\Bigg\\{  \\omega^2\\frac{1}{v^3}\\hbar\\omega \\bigg[ n_{\\rm B} +1/2\\bigg] \\Bigg\\}\n\\]\n\\[\ng(\\omega) = L^3\\bigg[ \\frac{12\\pi \\omega^2}{(2\\pi^3)v^3} \\bigg]\n\\]\nUtilizando la función Zeta de Riemann a \\(T_{\\rm bajas}\\)\n\\[\n\\langle E \\rangle = 9 N \\frac{(k_{\\rm B}T)^4}{\\hbar \\omega_{\\rm D}} \\frac{\\pi^4}{15}\\,; \\; \\omega_{\\rm D} = 6\\pi^2 n v^3\n\\]\ndonde \\(n\\) es la densidad de átomos por unidad de volumen,\n\\[\n\\langle E \\rangle = \\frac{\\partial \\langle E \\rangle }{\\partial T } = Nk_{\\rm B} \\frac{k_{\\rm B}T^3}{(\\hbar \\omega_{\\rm D})^3} \\frac{12 \\pi^4}{5} \\sim T^3\n\\]\n\n\n\n\\(T_{\\rm Debye}\\,[{\\rm K}]\\)\nMateriales\n\n\n\n\n215\nAg\n\n\n315\nCu\n\n\n1000\nSi\n\n\n1850\nDiamante\n\n\n\nEn los sólidos el calor es transportador por fonones y electrones.\nCapacidad calorífica y conductividad térmica\nFlujo de energía térmica, \\(j_{U}\\),\n\\[\nj_{U}=-\\kappa \\frac{d T }{dx}\n\\]\ndonde \\[\n\\kappa = \\frac{1}{3} C v \\ell\n\\] es la conductividad térmica .\n\\[\nv \\sim \\frac{d\\omega}{dk}$\n\\]\n\\(v\\) es la rapidez de los fonones y \\(\\ell\\) camino libre medio de los fonones."
  },
  {
    "objectID": "1_1_redydecorado.html",
    "href": "1_1_redydecorado.html",
    "title": "1  Red y decorado",
    "section": "",
    "text": "2 En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import *\na1 = 1.0 a2 = 1.0 # Definimos el vector vec_a1 vec_a1 = array([ a1, 0]) # Definimos el vector vec_a2 con una rotación θ = radians(60) vec_a2 = array([a2cos(θ), a2sin(θ)]) # Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] n1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) ) n1 = n1.flatten() n2 = n2.flatten()\nA = array( [vec_a1,vec_a2] ) coefs = column_stack((n1,n2)) # Obtenemos los puntos de la red red = dot( coefs,A )\nfig,ax = plt.subplots(figsize=((6,6)))\nax.scatter(red.T[0], red.T[1], label=f”\\(a_1={a1}\\)“) # Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\nax.legend() # Colocamos las marcas en el eje x acorde a los puntos de la red ax.set_xticks(red) # Colocamos unas líneas punteadas como guía ax.grid(ls=‘–’) # Colocamos las marcas en el eje y ax.set_yticks([0]) # Colocamos el texto en las marcas del eje y ax.set_yticklabels([“”])\nplt.show()"
  },
  {
    "objectID": "1_1_redydecorado.html#en-1d",
    "href": "1_1_redydecorado.html#en-1d",
    "title": "1  Red",
    "section": "1.1 En 1D",
    "text": "1.1 En 1D\n\n\nCode\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud del vector a1\na1 = 0.6\n# Definimos el vector vec_a1\nvec_a1 = array([a1])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4]\nn1 = arange( -4, 5 )\n# Obtenemos los puntos de la red\nred = dot( n1.reshape(len(n1),1),vec_a1 )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((4,2)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red, zeros_like(red), label=f\"$a_1={a1}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Colocamos el cuadro de leyenda\nax.legend()\n# Colocamos las marcas en el eje x acorde a los puntos de la red\nax.set_xticks(red)\n# Colocamos unas líneas punteadas como guía\nax.grid(ls='--')\n# Colocamos las marcas en el eje y\nax.set_yticks([0])\n# Colocamos el texto en las marcas del eje y\nax.set_yticklabels([\"\"])\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\nFigure 1.1: Ejemplo de red unidimensional"
  },
  {
    "objectID": "1_1_redydecorado.html#en-2d",
    "href": "1_1_redydecorado.html#en-2d",
    "title": "1  Red",
    "section": "1.2 En 2D",
    "text": "1.2 En 2D\n\n\nCode\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud de los vectores, a1 y a2\na1 = 1.0\na2 = 1.0\n# Definimos el vector vec_a1\nvec_a1 = array([       a1,         0])\n# Definimos el vector vec_a2 con una rotación de un ángulo θ\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n# tanto para n1 como n2\nn1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n# Con el fin de realizar las diferentes combinaciones lineales nos será \n# útil tener los coeficiente como un arreglo en una dimensión\nn1 = n1.flatten()\nn2 = n2.flatten()\n# Colocamos los vectores en una matriz, donde cada renglón es un vector\nA = array( [vec_a1,vec_a2] )\n# Colocamos los coeficientes en una matriz\ncoefs = column_stack((n1,n2))\n# Obtenemos los puntos de la red al multiplicar ambas matrices\nred = dot( coefs,A )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((6,6)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1}, a_2={a2}, θ={rad2deg(θ):.1f}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Graficamos los vectores de red\nax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\nax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n# Colocamos el cuadro de leyenda\nax.legend()\n\nax.set_aspect('equal')\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\nFigure 1.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_1_redydecorado.html#en-3d",
    "href": "1_1_redydecorado.html#en-3d",
    "title": "1  Red",
    "section": "1.3 En 3D",
    "text": "1.3 En 3D\n\n\nCode\na1,a2,a3 = 1,1,3\nvec_a1 = array([a1,0,0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ),0])\nvec_a3 = array([0,0,a3])\nA = array( [vec_a1,vec_a2,vec_a3] )\nn1,n2,n3 = mgrid[ -2:2:5J,-2:2:5J,-1:1:3J ]\nn1 = n1.flatten()\nn2 = n2.flatten()\nn3 = n3.flatten()\ncoefs = column_stack((n1,n2,n3))\n\nred = dot(coefs,A)\n\nimport plotly.graph_objects as go\n\ndef GraficaVector(a,vec_a,Color,label):\n    Tip    = 0.5\n    ColorP = Color\n    P      = vec_a\n    # Dirección de los vectores\n    Punit  = P/sqrt(dot(P,P))\n    # Vector P\n    TipP = go.Cone(x=[P[0]],y=[P[1]],z=[P[2]],\n                u=[Tip*Punit[0]],v=[Tip*Punit[1]],w=[Tip*Punit[2]],\n                colorscale=[[0, ColorP],[1.0, ColorP]],\n                sizemode=\"absolute\",\n                sizeref=Tip,\n                anchor=\"tip\",\n                showscale=False)\n    VecP = go.Scatter3d(x=[0,P[0]-Tip*Punit[0]],\n                        y=[0,P[1]-Tip*Punit[1]],\n                        z=[0,P[2]-Tip*Punit[2]],\n                        mode=\"lines\",name=label,\n                        line=dict(width=10,color=ColorP))\n    return TipP,VecP\n\nTipa1,Veca1 = GraficaVector(a1,vec_a1,'rgba(0, 191, 255, 60)',\"a1\")\nTipa2,Veca2 = GraficaVector(a2,vec_a2,'rgba(233,150,122, 60)',\"a2\")\nTipa3,Veca3 = GraficaVector(a3,vec_a3,'rgba( 50,205, 50, 60)',\"a2\")\n\nPLOTS = [go.Scatter3d(x=red.T[0], y=red.T[1], z=red.T[2], mode='markers',marker=dict(size=6),name=\"red\"),Tipa1,Veca1,Tipa2,Veca2,Tipa3,Veca3]\n\nfig = go.Figure(data=PLOTS)\nfig.show()\n\n\n\n\n                                                \nFigure 1.3: Ejemplo de red tridimensional\n\n\n\n\n\n\n\n\n\nRed (definición equivalente)\n\n\n\n\n\nUna red es un conjunto de puntos donde el entorno de cualquier punto es quivalente al entorno de cualquier otro."
  },
  {
    "objectID": "1_1_red.html#en-1d",
    "href": "1_1_red.html#en-1d",
    "title": "1  Red",
    "section": "1.1 En 1D",
    "text": "1.1 En 1D\n\n\nCode\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud del vector a1\na1 = 0.6\n# Definimos el vector vec_a1\nvec_a1 = array([a1])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4]\nn1 = arange( -4, 5 )\n# Obtenemos los puntos de la red\nred = dot( n1.reshape(len(n1),1),vec_a1 )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((4,2)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red, zeros_like(red), label=f\"$a_1={a1}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Colocamos el cuadro de leyenda\nax.legend()\n# Colocamos las marcas en el eje x acorde a los puntos de la red\nax.set_xticks(red)\n# Colocamos unas líneas punteadas como guía\nax.grid(ls='--')\n# Colocamos las marcas en el eje y\nax.set_yticks([0])\n# Colocamos el texto en las marcas del eje y\nax.set_yticklabels([\"\"])\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\nFigure 1.1: Ejemplo de red unidimensional"
  },
  {
    "objectID": "1_1_red.html#en-2d",
    "href": "1_1_red.html#en-2d",
    "title": "1  Red",
    "section": "1.2 En 2D",
    "text": "1.2 En 2D\n\n\nCode\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud de los vectores, a1 y a2\na1 = 1.0\na2 = 1.0\n# Definimos el vector vec_a1\nvec_a1 = array([       a1,         0])\n# Definimos el vector vec_a2 con una rotación de un ángulo θ\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n# tanto para n1 como n2\nn1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n# Con el fin de realizar las diferentes combinaciones lineales nos será \n# útil tener los coeficiente como un arreglo en una dimensión\nn1 = n1.flatten()\nn2 = n2.flatten()\n# Colocamos los vectores en una matriz, donde cada renglón es un vector\nA = array( [vec_a1,vec_a2] )\n# Colocamos los coeficientes en una matriz\ncoefs = column_stack((n1,n2))\n# Obtenemos los puntos de la red al multiplicar ambas matrices\nred = dot( coefs,A )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((6,6)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Graficamos los vectores de red\nax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\nax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n# Colocamos el cuadro de leyenda\nax.legend()\n\nax.set_aspect('equal')\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\nFigure 1.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_1_red.html#en-3d",
    "href": "1_1_red.html#en-3d",
    "title": "1  Red",
    "section": "1.3 En 3D",
    "text": "1.3 En 3D\n\n\nCode\na1,a2,a3 = 1,1,3\nvec_a1 = array([a1,0,0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ),0])\nvec_a3 = array([0,0,a3])\nA = array( [vec_a1,vec_a2,vec_a3] )\nn1,n2,n3 = mgrid[ -2:2:5J,-2:2:5J,-1:1:3J ]\nn1 = n1.flatten()\nn2 = n2.flatten()\nn3 = n3.flatten()\ncoefs = column_stack((n1,n2,n3))\n\nred = dot(coefs,A)\n\nimport plotly.graph_objects as go\n\ndef GraficaVector(a,vec_a,Color,label):\n    Tip    = 0.5\n    ColorP = Color\n    P      = vec_a\n    # Dirección de los vectores\n    Punit  = P/sqrt(dot(P,P))\n    # Vector P\n    TipP = go.Cone(x=[P[0]],y=[P[1]],z=[P[2]],\n                u=[Tip*Punit[0]],v=[Tip*Punit[1]],w=[Tip*Punit[2]],\n                colorscale=[[0, ColorP],[1.0, ColorP]],\n                sizemode=\"absolute\",\n                sizeref=Tip,\n                anchor=\"tip\",\n                showscale=False)\n    VecP = go.Scatter3d(x=[0,P[0]-Tip*Punit[0]],\n                        y=[0,P[1]-Tip*Punit[1]],\n                        z=[0,P[2]-Tip*Punit[2]],\n                        mode=\"lines\",name=label,\n                        line=dict(width=10,color=ColorP))\n    return TipP,VecP\n\nTipa1,Veca1 = GraficaVector(a1,vec_a1,'rgba(0, 191, 255, 60)',\"a1\")\nTipa2,Veca2 = GraficaVector(a2,vec_a2,'rgba(233,150,122, 60)',\"a2\")\nTipa3,Veca3 = GraficaVector(a3,vec_a3,'rgba( 50,205, 50, 60)',\"a2\")\n\nPLOTS = [go.Scatter3d(x=red.T[0], y=red.T[1], z=red.T[2], mode='markers',marker=dict(size=6),name=\"red\"),Tipa1,Veca1,Tipa2,Veca2,Tipa3,Veca3]\n\nfig = go.Figure(data=PLOTS)\nfig.show()\n\n\n\n\n                                                \nFigure 1.3: Ejemplo de red tridimensional\n\n\n\n\n\n\n\n\n\nRed (definición equivalente)\n\n\n\n\n\nUna red es un conjunto de puntos donde el entorno de cualquier punto es quivalente al entorno de cualquier otro."
  },
  {
    "objectID": "1_2_vectoresred.html",
    "href": "1_2_vectoresred.html",
    "title": "2  Vectores de red",
    "section": "",
    "text": "En el presente documento exploraremos que dada una red, los vectores de red no son únicos. Por efectos visuales, consideremos el ejemplo de la siguiente red bidimensional.\n\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\n\ndef GraficadeRed(vec_a1,vec_a2):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.1: Ejemplo de red bidimensional\n\n\n\n\nAlternativamente, podemos elegir\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\ny obtener la misma red\n\n\nCode\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.2: Ejemplo de red bidimensional\n\n\n\n\nOtra opción posible es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}0\\\\\\sqrt{3}\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.3: Ejemplo de red bidimensional\n\n\n\n\nUna opción más es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}5/2\\\\\\sqrt{3}/2\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}3/2\\\\\\sqrt{3}/2\\end{array} \\right]\n\\]\n\n\nCode\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.4: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-1",
    "href": "1_2_vectoresred.html#opción-1",
    "title": "2  Vectores de red",
    "section": "2.1 Opción 1",
    "text": "2.1 Opción 1\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\n\ndef GraficadeRed(vec_a1,vec_a2):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.1: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-2",
    "href": "1_2_vectoresred.html#opción-2",
    "title": "2  Vectores de red",
    "section": "2.2 Opción 2",
    "text": "2.2 Opción 2\nAlternativamente, podemos elegir\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\ny obtener la misma red\n\n\nCode\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-3",
    "href": "1_2_vectoresred.html#opción-3",
    "title": "2  Vectores de red",
    "section": "2.3 Opción 3",
    "text": "2.3 Opción 3\nOtra opción posible es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}0\\\\\\sqrt{3}\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.3: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-4",
    "href": "1_2_vectoresred.html#opción-4",
    "title": "2  Vectores de red",
    "section": "2.4 Opción 4",
    "text": "2.4 Opción 4\nUna opción más es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}5/2\\\\\\sqrt{3}/2\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}3/2\\\\\\sqrt{3}/2\\end{array} \\right]\n\\]\n\n\nCode\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.4: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\nObservación.\n\n\n\n\n\nNotamos que en las diferentes opciones los vectores de red pueden ser de tamaños diferentes."
  },
  {
    "objectID": "1_1_red.html#celda-primitiva",
    "href": "1_1_red.html#celda-primitiva",
    "title": "1  Red",
    "section": "1.4 Celda primitiva",
    "text": "1.4 Celda primitiva\n\n\n\n\n\n\nCelda primitiva (definición)\n\n\n\n\n\nEs la celda unitaria que contiene un punto de la red.\n\n\n\nHay dos formas de identificar la celda primitiva.\n\n\n\n\n\n\nA partir de los vectores de red\n\n\n\n\n\n\nEn 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n\n\n\n\n\n\n\n\n\n\nConstrucción de Wigner-Seitz\n\n\n\n\n\n\nEn 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz. En 3D, también, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza un plano perpendicular a cada segmento que pase por el punto medio. El volumen más pequeño encerrado por los planos es la celda primitiva de Wigner-Seitz."
  },
  {
    "objectID": "1_2_celdaprimitiva.html",
    "href": "1_2_celdaprimitiva.html",
    "title": "2  Celda primitiva",
    "section": "",
    "text": "Celda primitiva (definición)\n\n\n\n\n\nEs la celda unitaria que contiene un punto de la red.\n\n\n\nHay dos formas de identificar la celda primitiva.\n\n\n\n\n\n\nA partir de los vectores de red\n\n\n\n\n\n\nEn 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n\n\n\n\n\n\nCode\nfrom pylab import *\n\ndef GraficadeRedCell(vec_a1,vec_a2,polyx,polyy):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n\n    ax.fill(polyx,polyy,alpha=0.5,color=\"#50c878\")\n\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\npolyx = [0,vec_a1[0],vec_a1[0]+vec_a2[0],vec_a2[0],0]\npolyy = [0,vec_a1[1],vec_a1[1]+vec_a2[1],vec_a2[1],0]\n\nGraficadeRedCell(vec_a1,vec_a2,polyx,polyy)\n\n\n\n\n\nFigure 2.1: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\nConstrucción de Wigner-Seitz\n\n\n\n\n\n\nEn 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz. En 3D, también, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza un plano perpendicular a cada segmento que pase por el punto medio. El volumen más pequeño encerrado por los planos es la celda primitiva de Wigner-Seitz.\n\n\n\n\n\n\nCode\ndef FindInterection2D(v,w):\n    AA = np.array([v[0:2],w[0:2]])\n    bb = 0.5*np.array( [np.dot(v,v),np.dot(w,w)] )\n    return np.linalg.solve(AA, bb)\n\ndef BuildWignerSeitz(vec_a1,vec_a2):\n    puntosall = []\n    for n in arange(-1,2):\n        for m in arange(-1,2):\n            w = n*vec_a1+m*vec_a2\n            if (m!=0):\n                xp = FindInterection2D( vec_a1,w)\n                xn = FindInterection2D(-vec_a1,w)\n            if (n!=0):\n                yp = FindInterection2D( vec_a2,w)\n                yn = FindInterection2D(-vec_a2,w)\n            puntosall.append(xp)\n            puntosall.append(yp)\n            puntosall.append(xn)\n            puntosall.append(yn)\n    puntosall = array(puntosall).T\n\n    # Selecciona sólo los que están a la mínima distancia\n    dist    = sum(puntosall.T*puntosall.T,axis=1)\n    mindist = min(dist)\n    ϵ       = 1e-4\n    logical = dist&lt;(mindist+ϵ)\n    WignerSeitz = puntosall[:,logical]\n\n    # Quita los puntos repetidos (sólo funciona en 2D)\n    n   = 0\n    z   = WignerSeitz[0]+WignerSeitz[1]*1J\n    ang = angle(z)\n    while (n&lt;len(z)):\n        l_ind    = ones(len(z),dtype=bool)\n        l_ind[n] = False\n        \n        arrlog = logical_and( abs(ang-ang[n])&lt;ϵ, l_ind)\n\n        arrlog = array( arrlog==False)\n\n        z   = array(z[arrlog])\n        ang = angle(z)\n        n += 1\n        \n    indSort = argsort(ang)\n\n    WignerSeitz = array([real(z[indSort]),imag(z[indSort])])\n    return WignerSeitz\n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nWignerSeitz = BuildWignerSeitz(vec_a1,vec_a2)\n\nGraficadeRedCell(vec_a1,vec_a2,WignerSeitz[0],WignerSeitz[1])\n\n\n\n\n\nFigure 2.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_3_vectoresred.html#opción-1",
    "href": "1_3_vectoresred.html#opción-1",
    "title": "3  Vectores de red",
    "section": "3.1 Opción 1",
    "text": "3.1 Opción 1\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\n\ndef GraficadeRed(vec_a1,vec_a2):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.1: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_3_vectoresred.html#opción-2",
    "href": "1_3_vectoresred.html#opción-2",
    "title": "3  Vectores de red",
    "section": "3.2 Opción 2",
    "text": "3.2 Opción 2\nAlternativamente, podemos elegir\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\ny obtener la misma red\n\n\nCode\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_3_vectoresred.html#opción-3",
    "href": "1_3_vectoresred.html#opción-3",
    "title": "3  Vectores de red",
    "section": "3.3 Opción 3",
    "text": "3.3 Opción 3\nOtra opción posible es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}0\\\\\\sqrt{3}\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.3: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_3_vectoresred.html#opción-4",
    "href": "1_3_vectoresred.html#opción-4",
    "title": "3  Vectores de red",
    "section": "3.4 Opción 4",
    "text": "3.4 Opción 4\nUna opción más es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}5/2\\\\\\sqrt{3}/2\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}3/2\\\\\\sqrt{3}/2\\end{array} \\right]\n\\]\n\n\nCode\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.4: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\nObservación.\n\n\n\n\n\nNotamos que en las diferentes opciones los vectores de red pueden ser de tamaños diferentes. Ahora nos preguntamos, ¿qué pasa con el área del paralelogramo formado por los vectores de la red? ¿es diferente?\n\n\n\nUna forma de determinar el área del paralelogramo formado por los vectores de la red es utilizando el determinante de la matriz \\(A\\) couyos reglones son los vectores de la red.\n\n\n\n\n\n\nSea \\[\nA= \\left[ \\begin{array}{c} \\quad\\vec{a}_1\\quad\\\\ \\vec{a}_2\\end{array}\\right] =\n\\left[ \\begin{array}{cc} a_{1x}&a_{1y}\\\\a_{2x}&a_{2y}  \\end{array}  \\right]\n\\] entonces el área del paralelogramo es, \\[\n\\text{Área del paralelogramo} = {\\rm det}\\, A\n\\]\n\n\n\nCalculemos el área de las diferentes opciones anteriores\n\n\nCode\n# Opción 1\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 1\", det(A))\n# Opción 2\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 1\", det(A))\n# Opción 3\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 3\", det(A))\n# Opción 4\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 4\", det(A))\n\n\nOpción 1 0.8660254037844386\nOpción 1 0.8660254037844388\nOpción 3 0.8660254037844383\nOpción 4 0.8660254037844384"
  },
  {
    "objectID": "1_4_decorado.html",
    "href": "1_4_decorado.html",
    "title": "4  Decorado (Motif)",
    "section": "",
    "text": "Decorado (definición)\n\n\n\n\n\n\nLa descripción de los objetos en una celda unitaria respecto a los puntos de referencia en una celda se conocen como decorado (motif).\n\n\n\n\n\n\n\n\n\n\nEstructura cristalina\n\n\n\n\n\nUna estructura cristalina se compone de una red y un decorado.\n\n\n\nEjemplo: Panal de abeja\n\\[\n\\text{sitio 1: }\\frac{1}{3}\\vec{a}_1 + \\frac{1}{3}\\vec{a}_2\\quad\n\\text{sitio 2: }\\frac{2}{3}\\vec{a}_1 + \\frac{2}{3}\\vec{a}_2\n\\]\ndonde\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\ndef GenerarRed(n_1,n_2,a_1,a_2):\n  # -- Desarrollo técnico --\n  # Malla de enteros\n  N1,N2 = meshgrid(n_1,n_2)\n  # Cambiar a columnas\n  N1    = N1.flatten()\n  N2    = N2.flatten()\n  N1y2 = column_stack((N1,N2))\n  # Agrupar los vectores de red\n  avec = [a_1,a_2]\n\n  # Tomar todas las combinaciones\n  Rx,Ry = dot( N1y2,avec ).T\n  return Rx,Ry\n\na_1 = [1,0]\na_2 = [1/2,sqrt(3)/2]\n\nn_1 = arange(-4,4)\nn_2 = arange(-4,4)\n\nRx,Ry = GenerarRed(n_1,n_2,a_1,a_2)\n\nsitio1x = Rx + (1/3)*( a_1[0]+a_2[0] )\nsitio1y = Ry + (1/3)*( a_1[1]+a_2[1] )\n\nsitio2x = Rx + (2/3)*( a_1[0]+a_2[0] )\nsitio2y = Ry + (2/3)*( a_1[1]+a_2[1] )\n\nimport plotly.graph_objects as go\n\nData = [go.Scatter(x=sitio1x,y=sitio1y,mode='markers',showlegend=False),\n        go.Scatter(x=sitio2x,y=sitio2y,mode='markers',showlegend=False)]\n\nfig = go.Figure(data=Data)\nfig.update_xaxes(range=[-2,2])\nfig.update_yaxes(range=[-2,2])\nfig.update_layout(width=400, height=400)\nfig.show()\n\n\n\n\n                                                \nFigure 4.1: Ejemplo de estructura cristalina de panal de abeja."
  }
]