[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Propiedades Físicas de los Sólidos",
    "section": "",
    "text": "Prefacio\nEn el sitio se encuentran una selección de notas del curso de Propiedades de Física de los Sólidos (clave: 0087) de la Facultad de Química, UNAM.",
    "crumbs": [
      "Prefacio"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "2  Acerca de",
    "section": "",
    "text": "Acerca del sitio"
  },
  {
    "objectID": "vibra1d.html",
    "href": "vibra1d.html",
    "title": "4  Cadena Unidimensional",
    "section": "",
    "text": "from pylab import *\n\nt   = 0; κ = 1; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk1   = 0.2*pi/a\nk2   = 0.5*pi/a+2*pi/a\n#######\nω1   = sqrt(4*κ/m) * abs( sin(k1*a/2) )\nω2   = sqrt(4*κ/m) * abs( sin(k2*a/2) )\nu1   = A*exp(1J*ω1*t-1J*k1*n*a) # En lugar de δx_n\nu2   = A*exp(1J*ω2*t-1J*k2*n*a) # En lugar de δx_n\ny1   = zeros(len(xeq)) + u1\ny2   = zeros(len(xeq)) + u2\nx    = xeq # + u # δx\nprint(f\"k = {k1:.3f}, {k2:.3f}\")\nprint(f\"ω = {ω1:.3f}, {ω2:.3f}\")\n\nk = 0.628, 7.854\nω = 0.618, 1.414\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω1 # periodo\nveces  = 4       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nx0  = xeq\nu10 = A*exp(1J*ω1*t0-1J*k1*n*a)\ny10 = zeros(len(xeq)) + u10\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    u1 = A*exp(1J*ω1*t-1J*k1*n*a)\n    u2 = A*exp(1J*ω2*t-1J*k2*n*a)\n    y1 = zeros(len(xeq)) + u1\n    y2 = zeros(len(xeq)) + u2\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x,\n                                              y=y1.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0, \n                       y=y10.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=5,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  },
  {
    "objectID": "pyscf_H2.html",
    "href": "pyscf_H2.html",
    "title": "3  Molécula \\(H_2\\)",
    "section": "",
    "text": "# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n4 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n5 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n6 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "pyscf_H2.html#variación-de-la-geometría",
    "href": "pyscf_H2.html#variación-de-la-geometría",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.2 Variación de la geometría",
    "text": "3.2 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "pyscf_H2.html#función-que-devuelve-la-energía",
    "href": "pyscf_H2.html#función-que-devuelve-la-energía",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.3 Función que devuelve la energía",
    "text": "3.3 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "molecula_H2.html",
    "href": "molecula_H2.html",
    "title": "Molécula \\(H_2\\)",
    "section": "",
    "text": "Code\n# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n\n1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n\nCode\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n\n\nCode\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n2 Variación de la geometría\n\n\nCode\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n3 Función que devuelve la energía\n\n\nCode\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n\n\nCode\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n\n\nCode\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\n\n\nCode\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\n\nText(0, 0.5, 'E [Ha]')\n\n\n\n\n\n\nSource: Abrir en colab"
  },
  {
    "objectID": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "Molécula \\(H_2\\)",
    "section": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "molecula_H2.html#variación-de-la-geometría",
    "href": "molecula_H2.html#variación-de-la-geometría",
    "title": "Molécula \\(H_2\\)",
    "section": "1.1 Variación de la geometría",
    "text": "1.1 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "molecula_H2.html#función-que-devuelve-la-energía",
    "href": "molecula_H2.html#función-que-devuelve-la-energía",
    "title": "Molécula \\(H_2\\)",
    "section": "1.2 Función que devuelve la energía",
    "text": "1.2 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "eqnonda.html",
    "href": "eqnonda.html",
    "title": "5  Ecuación de onda",
    "section": "",
    "text": "La ecuación de onda es una ecuación diferencial parcial de segundo orden lineal y tiene la forma siguiente,\n\\[\n\\definecolor{purpura}{RGB}{160, 32, 240}\n\\newcommand{\\uu}{\\textcolor{purpura}{u}}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\nabla^2 \\uu\n\\tag{5.1}\\]\ndonde \\(v\\) es la rapidez de la onda y \\(\\uu\\) es una función de la posición y el tiempo, \\(\\uu = \\uu(\\vec{r},t)\\).\n\n\n\n\n\n\nEcuaciones de Maxwell\n\n\n\n\n\nEl campo eléctrico y el campo magnético siguen una ecuación de onda en el caso de que no haya cargas ni corrientes en el espacio\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{E} = c^2 \\nabla^2 \\vec{E} \\\\\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{B} = c^2 \\nabla^2 \\vec{B}\n\\]\n\n\n\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\tag{5.2}\\]\nConsideremos al espacio de forma discreta en el espacio\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h} \\approx \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h}\n\\]\nAlternativamente\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h} \\approx \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h}\n\\]\nEntonces la segunda derivada,\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} =\\lim_{h\\to 0} \\frac{\\frac{\\partial \\uu}{\\partial x}|_{x_0+h/2} - \\frac{\\partial \\uu}{\\partial x}|_{x_0-h/2} }{h}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} \\approx \\frac{u(x_0-h,t)-2u(x_0,t)+u(x_0+h,t)}{h}\n\\]"
  },
  {
    "objectID": "eqnonda.html#ejemplo",
    "href": "eqnonda.html#ejemplo",
    "title": "5  Ecuación de onda",
    "section": "5.1 Ejemplo",
    "text": "5.1 Ejemplo\nPosiblemente reconozca\n:::\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\begin{align}\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\end{align}\n\\tag{5.2}\\]"
  },
  {
    "objectID": "vibra1d.html#relación-de-dispersión",
    "href": "vibra1d.html#relación-de-dispersión",
    "title": "4  Cadena Unidimensional",
    "section": "4.1 Relación de dispersión",
    "text": "4.1 Relación de dispersión\n\\[\n\\definecolor{azul}{RGB}{0, 0, 139}\n\\newcommand{\\kk}{\\textcolor{red}{k}}\n\\]\n\\[\n\\omega^2 = 2\\frac{\\kappa }{m}\\bigg[  1-\\cos(\\kk a ) \\bigg]\n\\]\nEntonces, \\[\n\\omega(k) = \\sqrt{\\frac{4\\kappa}{m}} \\bigg| \\sin\\bigg( \\frac{\\kk a}{2} \\bigg) \\bigg|\n\\]"
  },
  {
    "objectID": "vibra1d.html#desplazamientos-del-equilibrio",
    "href": "vibra1d.html#desplazamientos-del-equilibrio",
    "title": "4  Cadena Unidimensional",
    "section": "4.2 Desplazamientos del equilibrio",
    "text": "4.2 Desplazamientos del equilibrio\n\\[\nx_n = x_n^{\\rm eq} + A e^{i\\omega t-i\\kk x_n^{\\rm eq}}\n\\]\ndonde \\(x_n^{\\rm eq}=na\\).\n\\[\n\\delta x_n = A e^{i\\omega t-i\\kk na}\n\\]\n\nfrom pylab import *\n\nt   = 0; κ = 100; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = 0.2*pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\nValor de k seleccionado: \nk = 0.628\nValor de ω seleccionado: \nω = 6.180\nPeriódo de oscilación: \nT = 6.180\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  },
  {
    "objectID": "matrizdinamica.html",
    "href": "matrizdinamica.html",
    "title": "6  Matriz dinámica",
    "section": "",
    "text": "Objetivo: describir de forma general cómo se mueven los átomos en un sólido\nLa estrategía general es: determinar la energía potencial, derivar las ecuaciones de movimiento y resolver las ecuaciones de movimiento buscando los modos normales.\nLa energía potencial\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ u_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#la-energía-potencial",
    "href": "matrizdinamica.html#la-energía-potencial",
    "title": "6  Matriz dinámica",
    "section": "6.1 La energía potencial",
    "text": "6.1 La energía potencial\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\vk}{\\vec{k}}\n\\newcommand{\\vRn}{\\vec{R}_{\\vn}}\n\\newcommand{\\vRm}{\\vec{R}_{\\vm}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ \\delta r_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}} = \\sum_{\\vm \\beta j} -U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#ecuaciones-de-movimiento",
    "href": "matrizdinamica.html#ecuaciones-de-movimiento",
    "title": "6  Matriz dinámica",
    "section": "6.2 Ecuaciones de movimiento",
    "text": "6.2 Ecuaciones de movimiento\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} = -\\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j} = 0\n\\]\nNotamos que tenemos \\(3rN\\) ecuaciones de movimiento, donde el \\(3\\) corresponde a las tres direcciones de movimiento en el espacio, \\(r\\) es el número de átomos en la celda unitaria y \\(N\\) son el número de celdas unitarias.\nProponemos una solución correspondiente a un modo normal, \\[\n\\udes{\\vn}{\\alpha}{i} = e^{i\\omega t-i\\vk\\cdot \\vRn }\\bigg[  \\frac{1}{\\sqrt{M}_\\alpha} u_{\\alpha i} \\bigg]\n\\]\nSustituimos en las ecuaciones de movimiento, \\[\n-\\omega^2 M_\\alpha \\bigg[  \\frac{1}{\\sqrt{M_\\alpha}} u_{\\alpha i} \\bigg] + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) } \\frac{1}{\\sqrt{M}_\\beta} u_{\\beta j} = 0\n\\]\n\\[\n-\\omega^2 \\sqrt{M}_\\alpha u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M}_\\beta}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\nNotamos que las ecuaciones anteriores son \\(3r\\) para cada celda unitaria \\(\\vn\\) y dado que todas las celdas son iguales, podemos elegir arbitrariamente \\(\\vn=\\vec{0}\\) y resolver. Entonces, dichas soluciones serán las mismas para todas.\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm }  \\bigg] u_{\\beta j} =0\n\\]\nLas \\(3r\\) ecuaciones podemos reescribirlas de forma matricial de la forma, \\[\n\\omega^2\\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right] =\n\\bigg[ \\frac{1}{\\sqrt{M_\\beta M_\\alpha}} \\sum_{\\vm} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm } \\bigg]_{\\alpha i,\\beta j} \\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right]\n\\]\ndonde la matriz del lado derecho se llama matriz dinámica.\n\\[\nD = \\left[\\begin{array}{cccc}\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\\ldots \\\\\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\n\\ldots \\\\\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\n\\ldots \\\\\n\\vdots&\\vdots&\\vdots&\\vdots\n\\end{array}\\right]\n\\]"
  },
  {
    "objectID": "matrizdinamica.html#otra-notación",
    "href": "matrizdinamica.html#otra-notación",
    "title": "6  Matriz dinámica",
    "section": "6.3 Otra notación",
    "text": "6.3 Otra notación\nAlternativamente,\n\\[\n\\sum_{\\beta j } -\\omega^2 \\delta_{\\alpha \\beta}\\delta_{ij} u_{\\beta j}+ \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]"
  },
  {
    "objectID": "calorespecifico.html",
    "href": "calorespecifico.html",
    "title": "7  Calor específico de los sólidos",
    "section": "",
    "text": "En 1819 Pierre Louis Dulong y Alexis Thérèse Petit establecieron que para casi todos los sólidos la capacidad calorífica esta dada por (ley de la Doulong-Petit),\n\\[\nC= 3 k_{\\rm B} \\text{ por átomo}\n\\]\n\\[\nC =3R\n\\]\ndonde \\(k_{\\rm B}=1.380649\\times 10^{-23} {\\rm J}\\cdot {\\rm K}^{-1}\\) es la constante de Boltzmann y \\(R=8.31446261815324 {\\rm J}\\cdot {\\rm K}^{-1}\\cdot {\\rm mol}^{-1}\\) es la constante molar de los gases.\nLa ly de Doulong-Petit es válida para temperatura ambiente.\n\n\n\nMaterial\nC/R\n\n\n\n\nAluminio (Al)\n2.91\n\n\nAntimonio (Sb)\n3.03\n\n\nCobre (Cu)\n2.94\n\n\nOro (Au)\n3.05\n\n\nPlata (Ag)\n2.99\n\n\nDiamante (C)\n0.735\n\n\n\nEn 1896 Boltzmann intento dar sentido a la Ley de Doulong Petit. Planteó, cada átomo del sólido esta ligado a otros átomos entonces cada átomo es un oscilador armónico. Es decir, su energía esta dada por \\(mv^2/2+kx^2/2\\) y utilizando el Teorema de equipartición de la energía, estableció que cada grado de libertad de oscilación contribuye en \\(k_{\\rm B}T\\) a la energía del sistema. En el caso de sólidos en tres dimensiones cada átomo contribuye a la energía en \\(3k_{\\rm B}T\\) por lo que\n\\[\nC=\\frac{d U}{d T } =3k_{\\rm B} \\text{ por átomo}\n\\]\n\n\nEn el caso de un gas, cada átomo contribuye a la energía en \\(mv_x^2/2+mv_y^2/2+mv_z^2/2\\) por lo que siguiendo el Teorema de Equipartición de la energía la capacidad calorífica por átomo es \\(C=3k_{\\rm B}/2\\).\nEn los inicios de los 1900, empezaron a realizar experimentos a bajas temperatura a algunos Kelvin. En 1907, Einstein intento explicar la capacidad calorífica a bajas temperaturas. Supuso que cada átomo es un oscilador armónico cuántico \\(E_n=\\hbar \\omega (n+1/2)\\).\nBoltzmann ya había establecido que la probabilidad de encontrar a un sistema a una energía \\(E_i\\) era \\[\n\\text{Probabilidad }\\propto e^{-\\beta E_i}=e^{-E_i/k_{\\rm B}T}\n\\]\nIntroduciendo la función de partición,\n\\[\nZ_{\\rm 1D} = \\sum_{n\\geq 0}  e^{-\\beta \\hbar \\omega (n+1/2)} = \\frac{e^{-\\beta \\hbar \\omega/2}}{1-e^{-\\beta \\hbar \\omega/2}}=\\frac{1}{2\\sinh (\\beta\\hbar\\omega/2)}\n\\]\n\n\nRecordemos que \\[\n\\sinh x=\\frac{e^x-e^{-x}}{2}\n\\]\npodemos calcular el valor medio de la energía\n\\[\n\\langle E \\rangle = -\\frac{1}{Z_{1D}} \\frac{\\partial Z_{1D}}{\\partial \\beta} =\\frac{\\hbar \\omega}{2} \\coth(\\beta \\hbar \\omega/2) = \\hbar \\omega \\bigg[ n_{\\rm B}(\\beta \\hbar \\omega) +\\frac{1}{2} \\bigg]\n\\]\ndonde \\[\nn_{\\rm B}(x)=\\frac{1}{e^x-1}\n\\]\nEntonces,\n\\[\nC = \\frac{\\partial \\langle E \\rangle}{\\partial T} = k_{\\rm B} (\\beta \\hbar \\omega)^2 \\frac{e^{\\beta \\omega}}{(e^{\\beta \\hbar \\omega}-1)^2}\n\\]\nEn el límite \\(T\\to \\infty\\)\n\\[\nC=k_{\\rm B} \\; \\Rightarrow \\; \\text{En tres dimensiones } C=3k_{\\rm B}\n\\]\nAún existía la problemática de bajas temperaturas el modelo de Einstein establece que \\(C\\sim e^{k_{\\rm B}T}\\) y experimentalmente se tenía que \\(C\\sim T^3\\).\nEn 1912, Debye desarrolla un modelo para determinar la cpacidad calorífica a bajas temperaturas. Las oscilaciones (osciladores armónicos) son similares a las del sonido (ondas sonoras). En las ondas sonoras \\[\n\\omega (k) = v| k|\n\\]\ndonde \\(v\\) es la rapidez del sonido.\nAnálogo a Einstein\n\\[\n\\langle E\\rangle = 3 \\sum_{\\vec{k}} \\hbar \\omega (\\vec{k}) \\bigg[ n_{\\rm B}(\\beta \\hbar \\omega) +1/2 \\bigg]\n\\]\nSustituimos que \\(\\omega (\\vec{k})=vk\\) y \\[\n\\sum_{k_x} \\to \\frac{L}{2\\pi} \\int dk_x\n\\]\n\\[\n\\langle E\\rangle = 3\\frac{L^3}{(2\\pi)^3} \\int d\\vec{k} \\Bigg\\{ \\hbar\\omega(\\vec{k}) \\bigg[  n_{\\rm B}(\\beta \\hbar \\omega) +1/2 \\bigg] \\Bigg\\}\n\\]\n\\[\n\\int d\\vec{k} \\to 4\\pi \\int_0^{\\infty} k^2 dk\n\\]\nUtilizando que \\(k=\\omega/v\\) entonces $dk=d$\n\\[\n\\langle E \\rangle = 3\\bigg(  \\frac{4\\pi L^3}{(2\\pi)^3} \\bigg) \\int_0^{\\omega_{\\rm corte}=\\omega_{\\rm D}} d\\omega \\Bigg\\{  \\omega^2\\frac{1}{v^3}\\hbar\\omega \\bigg[ n_{\\rm B} +1/2\\bigg] \\Bigg\\}\n\\]\n\\[\ng(\\omega) = L^3\\bigg[ \\frac{12\\pi \\omega^2}{(2\\pi^3)v^3} \\bigg]\n\\]\nUtilizando la función Zeta de Riemann a \\(T_{\\rm bajas}\\)\n\\[\n\\langle E \\rangle = 9 N \\frac{(k_{\\rm B}T)^4}{\\hbar \\omega_{\\rm D}} \\frac{\\pi^4}{15}\\,; \\; \\omega_{\\rm D} = 6\\pi^2 n v^3\n\\]\ndonde \\(n\\) es la densidad de átomos por unidad de volumen,\n\\[\n\\langle E \\rangle = \\frac{\\partial \\langle E \\rangle }{\\partial T } = Nk_{\\rm B} \\frac{k_{\\rm B}T^3}{(\\hbar \\omega_{\\rm D})^3} \\frac{12 \\pi^4}{5} \\sim T^3\n\\]\n\n\n\n\\(T_{\\rm Debye}\\,[{\\rm K}]\\)\nMateriales\n\n\n\n\n215\nAg\n\n\n315\nCu\n\n\n1000\nSi\n\n\n1850\nDiamante\n\n\n\nEn los sólidos el calor es transportador por fonones y electrones.\nCapacidad calorífica y conductividad térmica\nFlujo de energía térmica, \\(j_{U}\\),\n\\[\nj_{U}=-\\kappa \\frac{d T }{dx}\n\\]\ndonde \\[\n\\kappa = \\frac{1}{3} C v \\ell\n\\] es la conductividad térmica .\n\\[\nv \\sim \\frac{d\\omega}{dk}$\n\\]\n\\(v\\) es la rapidez de los fonones y \\(\\ell\\) camino libre medio de los fonones."
  },
  {
    "objectID": "1_1_redydecorado.html",
    "href": "1_1_redydecorado.html",
    "title": "1  Red y decorado",
    "section": "",
    "text": "2 En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import *\na1 = 1.0 a2 = 1.0 # Definimos el vector vec_a1 vec_a1 = array([ a1, 0]) # Definimos el vector vec_a2 con una rotación θ = radians(60) vec_a2 = array([a2cos(θ), a2sin(θ)]) # Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] n1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) ) n1 = n1.flatten() n2 = n2.flatten()\nA = array( [vec_a1,vec_a2] ) coefs = column_stack((n1,n2)) # Obtenemos los puntos de la red red = dot( coefs,A )\nfig,ax = plt.subplots(figsize=((6,6)))\nax.scatter(red.T[0], red.T[1], label=f”\\(a_1={a1}\\)“) # Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\nax.legend() # Colocamos las marcas en el eje x acorde a los puntos de la red ax.set_xticks(red) # Colocamos unas líneas punteadas como guía ax.grid(ls=‘–’) # Colocamos las marcas en el eje y ax.set_yticks([0]) # Colocamos el texto en las marcas del eje y ax.set_yticklabels([“”])\nplt.show()"
  },
  {
    "objectID": "1_1_redydecorado.html#en-1d",
    "href": "1_1_redydecorado.html#en-1d",
    "title": "1  Red",
    "section": "1.1 En 1D",
    "text": "1.1 En 1D\n\n\nCode\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud del vector a1\na1 = 0.6\n# Definimos el vector vec_a1\nvec_a1 = array([a1])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4]\nn1 = arange( -4, 5 )\n# Obtenemos los puntos de la red\nred = dot( n1.reshape(len(n1),1),vec_a1 )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((4,2)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red, zeros_like(red), label=f\"$a_1={a1}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Colocamos el cuadro de leyenda\nax.legend()\n# Colocamos las marcas en el eje x acorde a los puntos de la red\nax.set_xticks(red)\n# Colocamos unas líneas punteadas como guía\nax.grid(ls='--')\n# Colocamos las marcas en el eje y\nax.set_yticks([0])\n# Colocamos el texto en las marcas del eje y\nax.set_yticklabels([\"\"])\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\nFigure 1.1: Ejemplo de red unidimensional"
  },
  {
    "objectID": "1_1_redydecorado.html#en-2d",
    "href": "1_1_redydecorado.html#en-2d",
    "title": "1  Red",
    "section": "1.2 En 2D",
    "text": "1.2 En 2D\n\n\nCode\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud de los vectores, a1 y a2\na1 = 1.0\na2 = 1.0\n# Definimos el vector vec_a1\nvec_a1 = array([       a1,         0])\n# Definimos el vector vec_a2 con una rotación de un ángulo θ\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n# tanto para n1 como n2\nn1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n# Con el fin de realizar las diferentes combinaciones lineales nos será \n# útil tener los coeficiente como un arreglo en una dimensión\nn1 = n1.flatten()\nn2 = n2.flatten()\n# Colocamos los vectores en una matriz, donde cada renglón es un vector\nA = array( [vec_a1,vec_a2] )\n# Colocamos los coeficientes en una matriz\ncoefs = column_stack((n1,n2))\n# Obtenemos los puntos de la red al multiplicar ambas matrices\nred = dot( coefs,A )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((6,6)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1}, a_2={a2}, θ={rad2deg(θ):.1f}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Graficamos los vectores de red\nax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\nax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n# Colocamos el cuadro de leyenda\nax.legend()\n\nax.set_aspect('equal')\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\nFigure 1.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_1_redydecorado.html#en-3d",
    "href": "1_1_redydecorado.html#en-3d",
    "title": "1  Red",
    "section": "1.3 En 3D",
    "text": "1.3 En 3D\n\n\nCode\na1,a2,a3 = 1,1,3\nvec_a1 = array([a1,0,0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ),0])\nvec_a3 = array([0,0,a3])\nA = array( [vec_a1,vec_a2,vec_a3] )\nn1,n2,n3 = mgrid[ -2:2:5J,-2:2:5J,-1:1:3J ]\nn1 = n1.flatten()\nn2 = n2.flatten()\nn3 = n3.flatten()\ncoefs = column_stack((n1,n2,n3))\n\nred = dot(coefs,A)\n\nimport plotly.graph_objects as go\n\ndef GraficaVector(a,vec_a,Color,label):\n    Tip    = 0.5\n    ColorP = Color\n    P      = vec_a\n    # Dirección de los vectores\n    Punit  = P/sqrt(dot(P,P))\n    # Vector P\n    TipP = go.Cone(x=[P[0]],y=[P[1]],z=[P[2]],\n                u=[Tip*Punit[0]],v=[Tip*Punit[1]],w=[Tip*Punit[2]],\n                colorscale=[[0, ColorP],[1.0, ColorP]],\n                sizemode=\"absolute\",\n                sizeref=Tip,\n                anchor=\"tip\",\n                showscale=False)\n    VecP = go.Scatter3d(x=[0,P[0]-Tip*Punit[0]],\n                        y=[0,P[1]-Tip*Punit[1]],\n                        z=[0,P[2]-Tip*Punit[2]],\n                        mode=\"lines\",name=label,\n                        line=dict(width=10,color=ColorP))\n    return TipP,VecP\n\nTipa1,Veca1 = GraficaVector(a1,vec_a1,'rgba(0, 191, 255, 60)',\"a1\")\nTipa2,Veca2 = GraficaVector(a2,vec_a2,'rgba(233,150,122, 60)',\"a2\")\nTipa3,Veca3 = GraficaVector(a3,vec_a3,'rgba( 50,205, 50, 60)',\"a2\")\n\nPLOTS = [go.Scatter3d(x=red.T[0], y=red.T[1], z=red.T[2], mode='markers',marker=dict(size=6),name=\"red\"),Tipa1,Veca1,Tipa2,Veca2,Tipa3,Veca3]\n\nfig = go.Figure(data=PLOTS)\nfig.show()\n\n\n\n\n                                                \nFigure 1.3: Ejemplo de red tridimensional\n\n\n\n\n\n\n\n\n\nRed (definición equivalente)\n\n\n\n\n\nUna red es un conjunto de puntos donde el entorno de cualquier punto es quivalente al entorno de cualquier otro."
  },
  {
    "objectID": "1_1_red.html#en-1d",
    "href": "1_1_red.html#en-1d",
    "title": "1  Red",
    "section": "1.1 En 1D",
    "text": "1.1 En 1D\n\n\nCode\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud del vector a1\na1 = 0.6\n# Definimos el vector vec_a1\nvec_a1 = array([a1])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4]\nn1 = arange( -4, 5 )\n# Obtenemos los puntos de la red\nred = dot( n1.reshape(len(n1),1),vec_a1 )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((4,2)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red, zeros_like(red), label=f\"$a_1={a1}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Colocamos el cuadro de leyenda\nax.legend()\n# Colocamos las marcas en el eje x acorde a los puntos de la red\nax.set_xticks(red)\n# Colocamos unas líneas punteadas como guía\nax.grid(ls='--')\n# Colocamos las marcas en el eje y\nax.set_yticks([0])\n# Colocamos el texto en las marcas del eje y\nax.set_yticklabels([\"\"])\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\nFigure 1.1: Ejemplo de red unidimensional"
  },
  {
    "objectID": "1_1_red.html#en-2d",
    "href": "1_1_red.html#en-2d",
    "title": "1  Red",
    "section": "1.2 En 2D",
    "text": "1.2 En 2D\n\n\nMostrar código\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud de los vectores, a1 y a2\na1 = 1.0\na2 = 1.0\n# Definimos el vector vec_a1\nvec_a1 = array([       a1,         0])\n# Definimos el vector vec_a2 con una rotación de un ángulo θ\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n# tanto para n1 como n2\nn1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n# Con el fin de realizar las diferentes combinaciones lineales nos será \n# útil tener los coeficiente como un arreglo en una dimensión\nn1 = n1.flatten()\nn2 = n2.flatten()\n# Colocamos los vectores en una matriz, donde cada renglón es un vector\nA = array( [vec_a1,vec_a2] )\n# Colocamos los coeficientes en una matriz\ncoefs = column_stack((n1,n2))\n# Obtenemos los puntos de la red al multiplicar ambas matrices\nred = dot( coefs,A )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((6,6)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Graficamos los vectores de red\nax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\nax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n# Colocamos el cuadro de leyenda\nax.legend()\n\nax.set_aspect('equal')\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1.2: Ejemplo de red bidimensional",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Red</span>"
    ]
  },
  {
    "objectID": "1_1_red.html#en-3d",
    "href": "1_1_red.html#en-3d",
    "title": "1  Red",
    "section": "1.3 En 3D",
    "text": "1.3 En 3D\n\n\nMostrar código\na1,a2,a3 = 1,1,3\nvec_a1 = array([a1,0,0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ),0])\nvec_a3 = array([0,0,a3])\nA = array( [vec_a1,vec_a2,vec_a3] )\nn1,n2,n3 = mgrid[ -2:2:5J,-2:2:5J,-1:1:3J ]\nn1 = n1.flatten()\nn2 = n2.flatten()\nn3 = n3.flatten()\ncoefs = column_stack((n1,n2,n3))\n\nred = dot(coefs,A)\n\nimport plotly.graph_objects as go\n\ndef GraficaVector(a,vec_a,Color,label):\n    Tip    = 0.5\n    ColorP = Color\n    P      = vec_a\n    # Dirección de los vectores\n    Punit  = P/sqrt(dot(P,P))\n    # Vector P\n    TipP = go.Cone(x=[P[0]],y=[P[1]],z=[P[2]],\n                u=[Tip*Punit[0]],v=[Tip*Punit[1]],w=[Tip*Punit[2]],\n                colorscale=[[0, ColorP],[1.0, ColorP]],\n                sizemode=\"absolute\",\n                sizeref=Tip,\n                anchor=\"tip\",\n                showscale=False)\n    VecP = go.Scatter3d(x=[0,P[0]-Tip*Punit[0]],\n                        y=[0,P[1]-Tip*Punit[1]],\n                        z=[0,P[2]-Tip*Punit[2]],\n                        mode=\"lines\",name=label,\n                        line=dict(width=10,color=ColorP))\n    return TipP,VecP\n\nTipa1,Veca1 = GraficaVector(a1,vec_a1,'rgba(0, 191, 255, 60)',\"a1\")\nTipa2,Veca2 = GraficaVector(a2,vec_a2,'rgba(233,150,122, 60)',\"a2\")\nTipa3,Veca3 = GraficaVector(a3,vec_a3,'rgba( 50,205, 50, 60)',\"a2\")\n\nPLOTS = [go.Scatter3d(x=red.T[0], y=red.T[1], z=red.T[2], mode='markers',marker=dict(size=6),name=\"red\"),Tipa1,Veca1,Tipa2,Veca2,Tipa3,Veca3]\n\nfig = go.Figure(data=PLOTS)\nfig.show()\n\n\n\n\n                                                \n\n\nFigure 1.3: Ejemplo de red tridimensional\n\n\n\n\n\n\n\n\n\n\nRed (definición equivalente)\n\n\n\n\n\nUna red es un conjunto de puntos donde el entorno de cualquier punto es quivalente al entorno de cualquier otro.",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Red</span>"
    ]
  },
  {
    "objectID": "1_2_vectoresred.html",
    "href": "1_2_vectoresred.html",
    "title": "2  Vectores de red",
    "section": "",
    "text": "En el presente documento exploraremos que dada una red, los vectores de red no son únicos. Por efectos visuales, consideremos el ejemplo de la siguiente red bidimensional.\n\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\n\ndef GraficadeRed(vec_a1,vec_a2):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.1: Ejemplo de red bidimensional\n\n\n\n\nAlternativamente, podemos elegir\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\ny obtener la misma red\n\n\nCode\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.2: Ejemplo de red bidimensional\n\n\n\n\nOtra opción posible es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}0\\\\\\sqrt{3}\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.3: Ejemplo de red bidimensional\n\n\n\n\nUna opción más es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}5/2\\\\\\sqrt{3}/2\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}3/2\\\\\\sqrt{3}/2\\end{array} \\right]\n\\]\n\n\nCode\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.4: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-1",
    "href": "1_2_vectoresred.html#opción-1",
    "title": "2  Vectores de red",
    "section": "2.1 Opción 1",
    "text": "2.1 Opción 1\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\n\ndef GraficadeRed(vec_a1,vec_a2):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.1: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-2",
    "href": "1_2_vectoresred.html#opción-2",
    "title": "2  Vectores de red",
    "section": "2.2 Opción 2",
    "text": "2.2 Opción 2\nAlternativamente, podemos elegir\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\ny obtener la misma red\n\n\nCode\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-3",
    "href": "1_2_vectoresred.html#opción-3",
    "title": "2  Vectores de red",
    "section": "2.3 Opción 3",
    "text": "2.3 Opción 3\nOtra opción posible es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}0\\\\\\sqrt{3}\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.3: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_2_vectoresred.html#opción-4",
    "href": "1_2_vectoresred.html#opción-4",
    "title": "2  Vectores de red",
    "section": "2.4 Opción 4",
    "text": "2.4 Opción 4\nUna opción más es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}5/2\\\\\\sqrt{3}/2\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}3/2\\\\\\sqrt{3}/2\\end{array} \\right]\n\\]\n\n\nCode\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 2.4: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\nObservación.\n\n\n\n\n\nNotamos que en las diferentes opciones los vectores de red pueden ser de tamaños diferentes."
  },
  {
    "objectID": "1_1_red.html#celda-primitiva",
    "href": "1_1_red.html#celda-primitiva",
    "title": "1  Red",
    "section": "1.4 Celda primitiva",
    "text": "1.4 Celda primitiva\n\n\n\n\n\n\nCelda primitiva (definición)\n\n\n\n\n\nEs la celda unitaria que contiene un punto de la red.\n\n\n\nHay dos formas de identificar la celda primitiva.\n\n\n\n\n\n\nA partir de los vectores de red\n\n\n\n\n\n\nEn 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n\n\n\n\n\n\n\n\n\n\nConstrucción de Wigner-Seitz\n\n\n\n\n\n\nEn 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz. En 3D, también, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza un plano perpendicular a cada segmento que pase por el punto medio. El volumen más pequeño encerrado por los planos es la celda primitiva de Wigner-Seitz."
  },
  {
    "objectID": "1_2_celdaprimitiva.html",
    "href": "1_2_celdaprimitiva.html",
    "title": "2  Celda primitiva",
    "section": "",
    "text": "Celda primitiva (definición)\n\n\n\n\n\nEs la celda unitaria que contiene un punto de la red.\n\n\n\nHay dos formas de identificar la celda primitiva.\n\n\n\n\n\n\nA partir de los vectores de red\n\n\n\n\n\n\nEn 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\n\ndef GraficadeRedCell(vec_a1,vec_a2,polyx,polyy):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n\n    ax.fill(polyx,polyy,alpha=0.5,color=\"#50c878\")\n\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\npolyx = [0,vec_a1[0],vec_a1[0]+vec_a2[0],vec_a2[0],0]\npolyy = [0,vec_a1[1],vec_a1[1]+vec_a2[1],vec_a2[1],0]\n\nGraficadeRedCell(vec_a1,vec_a2,polyx,polyy)\n\n\n\n\n\n\n\n\nFigure 2.1: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\n\nConstrucción de Wigner-Seitz\n\n\n\n\n\n\nEn 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz. En 3D, también, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza un plano perpendicular a cada segmento que pase por el punto medio. El volumen más pequeño encerrado por los planos es la celda primitiva de Wigner-Seitz.\n\n\n\n\n\n\nMostrar código\ndef FindInterection2D(v,w):\n    AA = np.array([v[0:2],w[0:2]])\n    bb = 0.5*np.array( [np.dot(v,v),np.dot(w,w)] )\n    return np.linalg.solve(AA, bb)\n\ndef BuildWignerSeitz(vec_a1,vec_a2):\n    puntosall = []\n    for n in arange(-1,2):\n        for m in arange(-1,2):\n            w = n*vec_a1+m*vec_a2\n            if (m!=0):\n                xp = FindInterection2D( vec_a1,w)\n                xn = FindInterection2D(-vec_a1,w)\n            if (n!=0):\n                yp = FindInterection2D( vec_a2,w)\n                yn = FindInterection2D(-vec_a2,w)\n            puntosall.append(xp)\n            puntosall.append(yp)\n            puntosall.append(xn)\n            puntosall.append(yn)\n    puntosall = array(puntosall).T\n\n    # Selecciona sólo los que están a la mínima distancia\n    dist    = sum(puntosall.T*puntosall.T,axis=1)\n    mindist = min(dist)\n    ϵ       = 1e-4\n    logical = dist&lt;(mindist+ϵ)\n    WignerSeitz = puntosall[:,logical]\n\n    # Quita los puntos repetidos (sólo funciona en 2D)\n    n   = 0\n    z   = WignerSeitz[0]+WignerSeitz[1]*1J\n    ang = angle(z)\n    while (n&lt;len(z)):\n        l_ind    = ones(len(z),dtype=bool)\n        l_ind[n] = False\n        \n        arrlog = logical_and( abs(ang-ang[n])&lt;ϵ, l_ind)\n\n        arrlog = array( arrlog==False)\n\n        z   = array(z[arrlog])\n        ang = angle(z)\n        n += 1\n        \n    indSort = argsort(ang)\n\n    WignerSeitz = array([real(z[indSort]),imag(z[indSort])])\n    return WignerSeitz\n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nWignerSeitz = BuildWignerSeitz(vec_a1,vec_a2)\n\nGraficadeRedCell(vec_a1,vec_a2,WignerSeitz[0],WignerSeitz[1])\n\n\n\n\n\n\n\n\nFigure 2.2: Ejemplo de red bidimensional",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Celda primitiva</span>"
    ]
  },
  {
    "objectID": "1_3_vectoresred.html#opción-1",
    "href": "1_3_vectoresred.html#opción-1",
    "title": "3  Vectores de red",
    "section": "3.1 Opción 1",
    "text": "3.1 Opción 1\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\n\ndef GraficadeRed(vec_a1,vec_a2):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.1: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_3_vectoresred.html#opción-2",
    "href": "1_3_vectoresred.html#opción-2",
    "title": "3  Vectores de red",
    "section": "3.2 Opción 2",
    "text": "3.2 Opción 2\nAlternativamente, podemos elegir\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\ny obtener la misma red\n\n\nCode\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.2: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_3_vectoresred.html#opción-3",
    "href": "1_3_vectoresred.html#opción-3",
    "title": "3  Vectores de red",
    "section": "3.3 Opción 3",
    "text": "3.3 Opción 3\nOtra opción posible es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}0\\\\\\sqrt{3}\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(120^\\circ)\\\\\\sin(120^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.3: Ejemplo de red bidimensional"
  },
  {
    "objectID": "1_3_vectoresred.html#opción-4",
    "href": "1_3_vectoresred.html#opción-4",
    "title": "3  Vectores de red",
    "section": "3.4 Opción 4",
    "text": "3.4 Opción 4\nUna opción más es \\[\n\\vec{a}_1=\\left[\\begin{array}{c}5/2\\\\\\sqrt{3}/2\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}3/2\\\\\\sqrt{3}/2\\end{array} \\right]\n\\]\n\n\nCode\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nGraficadeRed(vec_a1,vec_a2)\n\n\n\n\n\nFigure 3.4: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\nObservación.\n\n\n\n\n\nNotamos que en las diferentes opciones los vectores de red pueden ser de tamaños diferentes. Ahora nos preguntamos, ¿qué pasa con el área del paralelogramo formado por los vectores de la red? ¿es diferente?\n\n\n\nUna forma de determinar el área del paralelogramo formado por los vectores de la red es utilizando el determinante de la matriz \\(A\\) couyos reglones son los vectores de la red.\n\n\n\n\n\n\nSea \\[\nA= \\left[ \\begin{array}{c} \\quad\\vec{a}_1\\quad\\\\ \\vec{a}_2\\end{array}\\right] =\n\\left[ \\begin{array}{cc} a_{1x}&a_{1y}\\\\a_{2x}&a_{2y}  \\end{array}  \\right]\n\\] entonces el área del paralelogramo es, \\[\n\\text{Área del paralelogramo} = {\\rm det}\\, A\n\\]\n\n\n\nCalculemos el área de las diferentes opciones anteriores\n\n\nCode\n# Opción 1\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 1\", det(A))\n# Opción 2\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 1\", det(A))\n# Opción 3\na1 = sqrt(3.0)\na2 = 1.0\nvec_a1 = array([       0, a1])\nθ = radians(120)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 3\", det(A))\n# Opción 4\nvec_a1 = array([5/2, sqrt(3)/2])\nvec_a2 = array([3/2, sqrt(3)/2])\nA = array( [vec_a1,vec_a2] )\nprint (\"Opción 4\", det(A))\n\n\nOpción 1 0.8660254037844386\nOpción 1 0.8660254037844387\nOpción 3 0.8660254037844383\nOpción 4 0.8660254037844384"
  },
  {
    "objectID": "1_4_decorado.html",
    "href": "1_4_decorado.html",
    "title": "4  Decorado (Motif)",
    "section": "",
    "text": "Decorado (definición)\n\n\n\n\n\n\nLa descripción de los objetos en una celda unitaria respecto a los puntos de referencia en una celda se conocen como decorado (motif).\n\n\n\n\n\n\n\n\n\n\nEstructura cristalina\n\n\n\n\n\nUna estructura cristalina se compone de una red y un decorado.\n\n\n\nEjemplo: Panal de abeja\n\\[\n\\text{sitio 1: }\\frac{1}{3}\\vec{a}_1 + \\frac{1}{3}\\vec{a}_2\\quad\n\\text{sitio 2: }\\frac{2}{3}\\vec{a}_1 + \\frac{2}{3}\\vec{a}_2\n\\]\ndonde\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nCode\nfrom pylab import *\ndef GenerarRed(n_1,n_2,a_1,a_2):\n  # -- Desarrollo técnico --\n  # Malla de enteros\n  N1,N2 = meshgrid(n_1,n_2)\n  # Cambiar a columnas\n  N1    = N1.flatten()\n  N2    = N2.flatten()\n  N1y2 = column_stack((N1,N2))\n  # Agrupar los vectores de red\n  avec = [a_1,a_2]\n\n  # Tomar todas las combinaciones\n  Rx,Ry = dot( N1y2,avec ).T\n  return Rx,Ry\n\na_1 = [1,0]\na_2 = [1/2,sqrt(3)/2]\n\nn_1 = arange(-4,4)\nn_2 = arange(-4,4)\n\nRx,Ry = GenerarRed(n_1,n_2,a_1,a_2)\n\nsitio1x = Rx + (1/3)*( a_1[0]+a_2[0] )\nsitio1y = Ry + (1/3)*( a_1[1]+a_2[1] )\n\nsitio2x = Rx + (2/3)*( a_1[0]+a_2[0] )\nsitio2y = Ry + (2/3)*( a_1[1]+a_2[1] )\n\nimport plotly.graph_objects as go\n\nData = [go.Scatter(x=sitio1x,y=sitio1y,mode='markers',showlegend=False),\n        go.Scatter(x=sitio2x,y=sitio2y,mode='markers',showlegend=False)]\n\nfig = go.Figure(data=Data)\nfig.update_xaxes(range=[-2,2])\nfig.update_yaxes(range=[-2,2])\nfig.update_layout(width=400, height=400)\nfig.show()\n\n\n\n\n                                                \nFigure 4.1: Ejemplo de estructura cristalina de panal de abeja."
  },
  {
    "objectID": "1_5_construccionsistematica.html",
    "href": "1_5_construccionsistematica.html",
    "title": "5  Construcción sistemática de las estructuras cristalinas",
    "section": "",
    "text": "Antes de revisar la construcción sistemática es recomendable revisar el sitio https://mathigon.org/course/transformations/introduction con el fin de tener clara la definición de simetría.\n\n\n\n\n\n\nSimetría\n\n\n\n\n\nUn objeto es simétrico si es invariante ante la aplicación de una cierta transformación.\n\n\n\nLos pasos de la construcción sistemática son cuatro: 1. Calsificar las celdas unitarias 2. Identificar las redes de Bravais 3. Agregar las simetrías puntuales 4. Agregar la combinación de traslaciones con simetrías puntuales.\nhttp://www.quadibloc.com/math/tilint.htm",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Construcción sistemática de las estructuras cristalinas</span>"
    ]
  },
  {
    "objectID": "1_7_fourier.html#serie-de-fourier",
    "href": "1_7_fourier.html#serie-de-fourier",
    "title": "7  Análisis de Fourier",
    "section": "",
    "text": "Serie de Fourier (real)\n\n\n\n\n\nUna función periódica, \\(f(x)\\), en el intervalor \\([-L/2,L/2]\\) puede escribirse como la serie (una serie es una suma infinita de terminos),\n\\[\n\\begin{equation*}\nf(x)=\\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos \\left( \\frac{2n\\pi}{L}x \\right) + b_n \\sin \\left( \\frac{2n\\pi}{L}x \\right) \\right]\n\\end{equation*}\n\\]\ndonde\n\\[\n\\begin{equation*}\na_0 = \\frac{2}{L} \\int\\limits_{-L/2}^{L/2} f(x) dx\n\\end{equation*}\n\\]\n\\[\n\\begin{equation*}\na_n = \\frac{2}{L} \\int\\limits_{-L/2}^{L/2} f(x) \\cos \\left( \\frac{2n\\pi}{L}x \\right) dx\n\\end{equation*}\n\\]\n\\[\n\\begin{equation*}\nb_n = \\frac{2}{L} \\int\\limits_{-L/2}^{L/2} f(x) \\sin \\left( \\frac{2n\\pi}{L}x \\right) dx\n\\end{equation*}\n\\]\n\n\n\n\n\n\n7.1.1 Ejemplo: recta\n\\[\nf(x) = x\\quad \\text{en el intervalo} \\quad [-L/2,L/2]\n\\]\n\n\nMostrar código\nfrom pylab import *\n\na = -10.0\nb = 10.0\nN = 6\n\nL = b-a\n\n# Tomar 100 puntos entre a y b, y los guarda\n# en la variable x\nx = linspace(a,b,1000)\nf = x\n\n# Coeficientes de Fourier\n\na_0 = 2.0/L*trapz(f,x)\n# Con el fin de realizar la integral utilizamos\n# la función trapz( ). tapz realiza la integral \n# numérica aporximando el área bajo la curva \n# por trapecios.\n\n# SF: Suma de Fourier\nSF  = zeros_like(x) \nSF += a_0/2.0\n\nfor n in range(1,N+1):\n    a_n = 2.0/L*trapz( f*cos(2*n*pi/L*x),x)\n    b_n = 2.0/L*trapz( f*sin(2*n*pi/L*x),x)\n    SF += a_n*cos(2*n*pi/L*x)+b_n*sin(2*n*pi/L*x)\n\n# SF2: Suma de Fourier\nSF2  = zeros_like(x) \nSF2 += a_0/2.0\n\nfor n in range(1,2*N+1):\n    a_n = 2.0/L*trapz( f*cos(2*n*pi/L*x),x)\n    b_n = 2.0/L*trapz( f*sin(2*n*pi/L*x),x)\n    SF2 += a_n*cos(2*n*pi/L*x)+b_n*sin(2*n*pi/L*x)\n\nfig,ax = plt.subplots(figsize=(4,4))    \nax.plot(x,SF,color='r',label=f\"sN, N={N}\")\nax.plot(x,SF2,color='b',label=f\"sN, N={2*N}\")\nax.plot(x,f,ls='-',lw=2, color='k',label='f(x)=x')\nax.set_xticks([-L/2,0,L/2])\nax.set_yticks([-L/2,0,L/2])\nax.set_xticklabels([\"-L/2\",\"0\",\"L/2\"])\nax.set_yticklabels([\"-L/2\",\"0\",\"L/2\"])\n\nax.legend()\n\nplt.show();\n\n\n\n\n\n\n\n\n\n\n\n7.1.2 Ejemplo: función escalón\n\n\nMostrar código\nfrom scipy import integrate\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\na =-10.0\nb = 10.0\n\nN = 11\n\nT=b-a\n\nx=np.linspace(-10,10,10000)\nf = piecewise(x,x&gt;=0,[1,0])\n\na_0 = 2.0/T*integrate.quad(lambda x: np.piecewise(x,x&gt;=0,[1,0]),a,b)[0]\ny = a_0/2.0*x**0.0\n\n# Coeficientes de Fourier\n\na_0 = 2.0/L*trapz(f,x)\n\n# SF: Suma de Fourier\nSF  = zeros_like(x) \nSF += a_0/2.0\n\nfor n in range(1,N+1):\n    a_n = 2.0/L*trapz( f*cos(2*n*pi/L*x),x)\n    b_n = 2.0/L*trapz( f*sin(2*n*pi/L*x),x)\n    SF = SF + a_n*cos(2*n*pi/L*x)+b_n*sin(2*n*pi/L*x)\n\n\nfig,ax = plt.subplots(figsize=(4,4))\nax.plot(x,SF,color='r',label=f\"sN, N={N}\")\nax.plot(x,f,label=\"Step function\")\nax.set_xticks([-L/2,0,L/2])\nax.set_yticks([0,1])\nax.set_xticklabels([\"-L/2\",\"0\",\"L/2\"])\n\n\nax.legend()\n\nplt.show();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSerie de Fourier (compleja)\n\n\n\n\n\nUna función periódica, \\(f(x)\\), en el intervalor \\([-L/2,L/2]\\) puede escribirse como la serie (una serie es una suma infinita de terminos),\n\\[\n\\begin{equation*}\nf(x) = \\lim_{N\\to \\infty} s_{N} = \\lim_{N\\to \\infty} \\sum_{n=-N}^{N} c_{n} e^{i\\frac{2\\pi}{L} nx}\n\\end{equation*}\n\\]\ndonde\n\\[\n\\begin{equation}\nc_n = c_{Rn}+ic_{In}\n\\end{equation}\n\\] \\[\n\\begin{equation*}\nc_{Rn} = \\frac{1}{L} \\int\\limits_{-L/2}^{L/2} {\\rm Re}\\{f(x)\\} e^{-i\\frac{2\\pi}{L} nx} dx\n\\end{equation*}\n\\] \\[\n\\begin{equation*}\nc_{In} = \\frac{1}{L} \\int\\limits_{-L/2}^{L/2} {\\rm Im}\\{f(x)\\} e^{-i\\frac{2\\pi}{L} nx} dx\n\\end{equation*}\n\\]\n\n\n\nNotamos que \\(c_n\\) es complejo. Alternativamente podemos escribir \\[\nc_n=\\langle n|f\\rangle\n\\]\nDefinimos \\(k_n\\equiv 2\\pi n /L\\), entonces podemos escribir\n\\[\ne^{\\ii\\frac{2\\pi}{L}} = e^{\\ii k_n x} \\rightarrow |n\\rangle\n\\]\nUtilizando la notación de bra-ket\n\\[\nf(x) = \\sum_{k_n} |n\\rangle \\langle n | f\\rangle\n\\]\nDefinimos\n\\[\n\\tilde{f}_{k_n}\\equiv L c_n = \\int_{-L/2}^{L/2} e^{-\\ii k_n x} f(x) dx\n\\] Entonces, \\[\nf(x) = \\frac{1}{L} \\sum_{k_n} \\tilde{f}_{k_n} e^{\\ii k_n x}\n\\]\nEl siguiente paso es extender la definición de la serie de Fourier del intervalo \\((-L/2,L/2)\\) a \\((-\\infty,\\infty)\\).\n¿Qué pasa con \\(k_n=2\\pi n/L\\) cuando \\(L\\) se hace más grande?\n\nUn continuo de puntos\n\nEn general, \\[\n\\Delta k = k_{n+1}-k_n = \\frac{2\\pi}{L}\n\\]\nAnalicemos \\(\\sum_{k_n}\\)\n\\[\n\\sum_{k_n} 1 = \\sum_{k_n} \\frac{\\Delta k}{\\Delta k} = \\frac{1}{\\Delta k } \\sum_{k_n} = \\frac{L}{2\\pi} \\sum_{k_n}\\Delta k \\quad \\Rightarrow \\lim_{L\\to \\infty} \\rightarrow \\quad \\frac{L}{2\\pi} \\int_{-\\infty}^{\\infty} dk\n\\]",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis de Fourier</span>"
    ]
  },
  {
    "objectID": "1_7_fourier.html#transformada-de-fourier",
    "href": "1_7_fourier.html#transformada-de-fourier",
    "title": "7  Análisis de Fourier",
    "section": "7.2 Transformada de Fourier",
    "text": "7.2 Transformada de Fourier",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis de Fourier</span>"
    ]
  },
  {
    "objectID": "1_6_redreciproca.html",
    "href": "1_6_redreciproca.html",
    "title": "6  Red recíproca",
    "section": "",
    "text": "Red recíproca\n\n\n\n\n\nUn punto de la red recíproca \\(\\vec{G}\\) cumple que \\(e^{\\ii \\vec{G}\\cdot \\vec{R}}=1\\) donde \\(\\vec{R}\\) son los puntos de la red real.\n\n\n\nNotamos que los puntos \\(\\vec{G}\\) que cumplen la definición tienen dimensiones de \\[\n[\\vec{G}] = \\frac{1}{\\text{longitud}}\\,,\n\\] es decir las dimensiones recíprocas de la red \\(\\vec{R}\\), \\[\n[\\vec{R}]= \\text{longitud}\\,.\n\\]\nCon el fin de determinar los puntos de la red recíproca, \\(\\vec{G}\\) consideramos las siguientes dos suposiciones\n\nLos puntos \\(\\{ \\vec{G} \\}\\) forman una red, entonces podemos escribirlos como una combinación lineal de coeficientes enteros de vectores linealmente independientes.\n\n\\[\n\\vec{G}=m_1\\vec{b}_1+m_2\\vec{b}_2+m_3\\vec{b}_3\n\\]\n\nLos vectores base de la red recíproca cumplen que\n\n\\[\n\\vec{a}_i\\cdot \\vec{b}_j = 2\\pi \\delta_{ij}\n\\] donde \\(\\vec{a}_i\\) son los vectores base de la red \\(\\{\\vec{R}\\}\\).\nIdentificamos que podemos escribir la relación previa de forma ordenada como matriz\n\\[\n\\left[\n\\begin{array}{ccc}\n\\vec{a}_1\\cdot \\vec{b}_1 & \\vec{a}_1\\cdot \\vec{b}_2 & \\vec{a}_1\\cdot \\vec{b}_3 \\\\\n\\vec{a}_2\\cdot \\vec{b}_1 & \\vec{a}_2\\cdot \\vec{b}_2 & \\vec{a}_2\\cdot \\vec{b}_3 \\\\\n\\vec{a}_3\\cdot \\vec{b}_1 & \\vec{a}_3\\cdot \\vec{b}_2 & \\vec{a}_3\\cdot \\vec{b}_3\n\\end{array}\n\\right]=\\left[\n\\begin{array}{ccc}\n2\\pi & 0 & 0\\\\\n0 & 2\\pi & 0 \\\\\n0 & 0 & 2\\pi  \n\\end{array}\n\\right]\n\\] El lado izquierdo podemos escribirlo como el producto de dos matrices\n\\[\n\\left[\n\\begin{array}{c}\n\\qquad \\vec{a}_1 \\qquad \\\\\n------\\\\\n\\qquad \\vec{a}_2 \\qquad \\\\\n------\\\\\n\\qquad \\vec{a}_3 \\qquad \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{ccccc}\n&|&&|&\\\\\n&|&&|&\\\\\n\\vec{b}_1&|&\\vec{b}_2&|&\\vec{b_3}\\\\\n&|&&|&\\\\\n&|&&|&\n\\end{array}\n\\right]=\\left[\n\\begin{array}{ccc}\n2\\pi & 0 & 0\\\\\n0 & 2\\pi & 0 \\\\\n0 & 0 & 2\\pi  \n\\end{array}\n\\right]\n\\] Definimos las matrices \\[\nA\\equiv \\left[\n\\begin{array}{c}\n\\qquad \\vec{a}_1 \\qquad \\\\\n------\\\\\n\\qquad \\vec{a}_2 \\qquad \\\\\n------\\\\\n\\qquad \\vec{a}_3 \\qquad \\\\\n\\end{array}\n\\right]\n\\] y \\[\nB\\equiv \\left[\\begin{array}{ccccc}\n&|&&|&\\\\\n&|&&|&\\\\\n\\vec{b}_1&|&\\vec{b}_2&|&\\vec{b_3}\\\\\n&|&&|&\\\\\n&|&&|&\n\\end{array}\n\\right]\n\\] Por lo que,\n\\[\nAB = 2\\pi \\mathbb{I}\n\\] donde \\(\\mathbb{I}\\) es la matriz identidad."
  },
  {
    "objectID": "1_8_particulalibre.html#visualización-de-la-solución",
    "href": "1_8_particulalibre.html#visualización-de-la-solución",
    "title": "8  Partícula libre en una dimensión",
    "section": "",
    "text": "8.1.1 Caso \\(c_1=1\\) y \\(c_2=0\\)\nConsidermos el caso de \\(c_1=1\\) y \\(c_2=0\\), por lo que \\[\n\\psi\\iprn x \\fprn = e^{ {\\rm i}k x }\n\\]\n\n\n\n\n\n\nGráfica\n\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\n# Masa de un electrón\nm = 9.1093837e-31  # (kg)\n# Constante de planck entre 2π\nħ = 1.05457182e-34 # (J·s)\n# 10 eV\nE = 10*1.602e-19 # (J)\nk = sqrt( 2*m*E/(ħ*ħ) )\n\nprint( \"Caso. Un electrón con energía de 10 eV.\")\nprint( f\"k = {k:.3e} (1/m)\")\nπ  = pi\nx  = linspace( -3*2*π/k,3*2*π/k,1000 )\nψ  = exp( 1J*k*x)\nψ2 = conj(ψ)*ψ\n\n# Graficación\n\nfig,ax = plt.subplots(ncols=1,nrows=2,figsize=(6,4),sharex=True)\nfig.subplots_adjust(hspace=0.1)\n\nax[0].plot(x,ψ.real,label='Re ψ')\nax[0].plot(x,ψ.imag,label='Im ψ')\n\nax[0].legend(loc=0)\n\nax[1].plot(x,ψ2.real,label='|ψ|²')\nax[1].fill_between(x,ψ2.real,zeros_like(x),alpha=0.3)\n\nax[1].legend(loc=0)\n\nax[1].set_xlabel('x (m)');\n\n\nCaso. Un electrón con energía de 10 eV.\nk = 1.620e+10 (1/m)\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.1.1.1 Visualización \\({\\rm Re}\\Psi\\)\nRecordemos que la función de onda depende del tiempo y definimos\n\\[\n\\omega = E/\\hbar\n\\]\n\\[\n\\Psi \\iprn x,t \\fprn = e^{-\\ii \\omega t } e^{ {\\rm i}k x }\n\\]\n\n\n\n\n\n\nVisualización \\({\\rm Re}\\Psi\\)\n\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\n# import pandas as pd\nimport plotly.graph_objects as go\n\n# Masa de un electrón\nm = 9.1093837e-31  # (kg)\n# Constante de planck entre 2π\nħ = 1.05457182e-34 # (J·s)\n# 10 eV\nE = 10*1.602e-19 # (J)\nk = sqrt( 2*m*E/(ħ*ħ) )\nω   = E/ħ\nπ  = pi\nprint( \"Caso. Un electrón con energía de 10 eV.\")\nprint( f\"k = {k:.3e} (1/m)\")\nprint( f\"ω = {ω:.3e} (1/s)\" )\n# Conversióna femptosegundos\nω /= 1e15\nnpts_x = 2000\nnpts_t = 100\n# x,t = meshgrid( linspace(-3*2*π/k,3*2*π/k,npts_x),linspace(-1*2*π/ω,1*2*π/ω,npts_t) )\nX   = linspace(-3*2*π/k,3*2*π/k,npts_x)\nT   = linspace(0,4*2*π/ω,npts_t)\nΨ   = exp(-1J*ω*T[0])*exp(1J*k*X)\nReΨ = Ψ.real\n\n\ncuadros = []\nfor n in range(1,npts_t):\n    Ψ = exp(-1J*ω*T[n])*exp(1J*k*X)\n    cuadros.append( go.Frame(data=[go.Scatter(x=X, y=Ψ.real,mode=\"lines\")],layout=go.Layout(title=f\"t={T[n]:.2f} (fs)\")) )\n\ncuadros = list(cuadros)\n\nfig = go.Figure(\n    data=[go.Scatter(x=X, y=ReΨ,mode=\"lines\")],\n    layout=go.Layout(\n        title=\"t=0.00 (fs)\",\n        xaxis_title=\"x (nm)\",\n        yaxis_title=\"Re[Ψ]\",\n        updatemenus=[dict(type=\"buttons\",\n                          x=0.5,y=1.1,\n                          buttons=[dict(label=\"Reproducir\",\n                                        method=\"animate\",\n                                        args=[None,\n                                        dict(frame=dict(duration=100,redraw=True),\n                                        transition=dict(duration=0,easing=None))] )])]\n                          \n    ),\n    frames = cuadros\n)\n\nfig.show()\n\n\nCaso. Un electrón con energía de 10 eV.\nk = 1.620e+10 (1/m)\nω = 1.519e+16 (1/s)\n\n\n                                                \n\n\n\n\n\n\n\n8.1.1.2 Visualización \\({\\rm Im}\\Psi\\)\n\n\n\n\n\n\nVisualización \\({\\rm Re}\\Psi\\)\n\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\n# import pandas as pd\nimport plotly.graph_objects as go\n\n# Masa de un electrón\nm = 9.1093837e-31  # (kg)\n# Constante de planck entre 2π\nħ = 1.05457182e-34 # (J·s)\n# 10 eV\nE = 10*1.602e-19 # (J)\nk = sqrt( 2*m*E/(ħ*ħ) )\nω   = E/ħ\nπ  = pi\nprint( \"Caso. Un electrón con energía de 10 eV.\")\nprint( f\"k = {k:.3e} (1/m)\")\nprint( f\"ω = {ω:.3e} (1/s)\" )\n# Conversióna femptosegundos\nω /= 1e15\nnpts_x = 2000\nnpts_t = 100\n# x,t = meshgrid( linspace(-3*2*π/k,3*2*π/k,npts_x),linspace(-1*2*π/ω,1*2*π/ω,npts_t) )\nX   = linspace(-3*2*π/k,3*2*π/k,npts_x)\nT   = linspace(0,4*2*π/ω,npts_t)\nΨ   = exp(-1J*ω*T[0])*exp(1J*k*X)\nImΨ = Ψ.imag\n\n\ncuadros = []\nfor n in range(1,npts_t):\n    Ψ   = exp(-1J*ω*T[n])*exp(1J*k*X)\n    cuadros.append( go.Frame(data=[go.Scatter(x=X, y=Ψ.imag,mode=\"lines\",line=dict(color='firebrick'))],layout=go.Layout(title=f\"t={T[n]:.2f} (fs)\")) )\n\nfig = go.Figure(\n    data=[go.Scatter(x=X, y=ImΨ,mode=\"lines\",line=dict(color='firebrick'))],\n    layout=go.Layout(\n        title=\"t=0.00 (fs)\",\n        xaxis_title=\"x (nm)\",\n        yaxis_title=\"Im[Ψ]\",\n        updatemenus=[dict(type=\"buttons\",\n                          x=0.5,y=1.0,\n                          buttons=[dict(label=\"Reproducir\",\n                                        method=\"animate\",\n                                        args=[None,\n                                        dict(frame=dict(duration=100,redraw=True),\n                                        transition=dict(duration=0,easing=None))] )])]\n                          \n    ),\n    frames = cuadros\n)\n\nfig.show()\n\n\nCaso. Un electrón con energía de 10 eV.\nk = 1.620e+10 (1/m)\nω = 1.519e+16 (1/s)\n\n\n                                                \n\n\n\n\n\n\n\n8.1.1.3 Visualización flechas\n\n\n\n\n\n\nViualización \\(({\\rm Re}\\Psi, {\\rm Im}\\Psi)\\)\n\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\n# import pandas as pd\nimport plotly.graph_objects as go\nimport plotly.figure_factory as ff\n\n\n# Masa de un electrón\nm = 9.1093837e-31  # (kg)\n# Constante de planck entre 2π\nħ = 1.05457182e-34 # (J·s)\n# 10 eV\nE = 10*1.602e-19 # (J)\nk = sqrt( 2*m*E/(ħ*ħ) )\nω   = E/ħ\nprint( \"Caso. Un electrón con energía de 10 eV.\")\nprint( f\"k = {k:.3e} (1/m)\")\nprint( f\"ω = {ω:.3e} (1/s)\" )\nω /= 1e15 # Conversióna femtosegundos\nk /= 1e9  # Conversión a nanometros \nnpts_x = 16\nnpts_t = 100\n# x,t = meshgrid( linspace(-3*2*π/k,3*2*π/k,npts_x),linspace(-1*2*π/ω,1*2*π/ω,npts_t) )\nX   = linspace(-3*2*π/k,3*2*π/k,npts_x)\nY   = zeros_like(X)\nT   = linspace(0,4*2*π/ω,npts_t)\nΨ   = exp(-1J*ω*T[0])*exp(1J*k*X)\nReΨ = Ψ.real\nImΨ = Ψ.imag\n\n\ncuadros = []\nfor n in range(1,npts_t):\n    Ψ   = exp(-1J*ω*T[n])*exp(1J*k*X)\n    ReΨ = Ψ.real\n    ImΨ = Ψ.imag\n    fig = ff.create_quiver(X, Y, ReΨ, ImΨ,angle=pi/6)\n    cuadros.append( go.Frame(data=fig.data,layout=go.Layout(title=f\"t={T[n]:.2f} (fs)\")) )\n\n\nfig0 = ff.create_quiver(X, Y, ReΨ, ImΨ,angle=pi/6)\nfig = go.Figure(\n    data = fig0.data,\n    layout=go.Layout(\n        title=\"t=0.00 (fs)\",\n        xaxis_title=\"x (nm)\",\n        updatemenus=[dict(type=\"buttons\",\n                          x=0.5,y=1.0,\n                          buttons=[dict(label=\"Reproducir\",\n                                        method=\"animate\",\n                                        args=[None,\n                                        dict(frame=dict(duration=100,redraw=True),\n                                        transition=dict(duration=0,easing=None))] )])]\n                          \n    ),\n    frames = cuadros\n)\nfig.update_yaxes(range=[-1,1])\n\nfig.show()\n\n\nCaso. Un electrón con energía de 10 eV.\nk = 1.620e+10 (1/m)\nω = 1.519e+16 (1/s)\n\n\n                                                \n\n\n\n\n\n\n\n\n8.1.2 Caso \\(c_1=0\\) y \\(c_2=1\\)\nConsidermos el caso de \\(c_1=1\\) y \\(c_2=0\\), por lo que \\[\n\\psi\\iprn x \\fprn = e^{ -{\\rm i}k x }\n\\]\n\n8.1.2.1 Visualización \\({\\rm Re}\\Psi\\) y \\({\\rm Im}\\Psi\\)\nRecordemos que la función de onda depende del tiempo y definimos \\[\n\\omega =E/\\hbar\n\\]\n\\[\n\\Psi \\iprn x,t \\fprn = e^{-\\ii \\omega t } e^{ -{\\rm i}k x }\n\\]\n\n\n\n\n\n\nViualización \\({\\rm Re}\\Psi\\) e \\({\\rm Im}\\Psi\\)\n\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Masa de un electrón\nm = 9.1093837e-31  # (kg)\n# Constante de planck entre 2π\nħ = 1.05457182e-34 # (J·s)\n# 10 eV\nE = 10*1.602e-19 # (J)\nk = sqrt( 2*m*E/(ħ*ħ) )\nω   = E/ħ\nprint( \"Caso. Un electrón con energía de 10 eV.\")\nprint( f\"k = {k:.3e} (1/m)\")\nprint( f\"ω = {ω:.3e} (1/s)\" )\n# Conversióna femptosegundos\nω /= 1e15\nnpts_x = 2000\nnpts_t = 100\n# x,t = meshgrid( linspace(-3*2*π/k,3*2*π/k,npts_x),linspace(-1*2*π/ω,1*2*π/ω,npts_t) )\nX   = linspace(-3*2*π/k,3*2*π/k,npts_x)\nT   = linspace(0,4*2*π/ω,npts_t)\nΨ   = exp(-1J*ω*T[0])*exp(-1J*k*X)\nReΨ = Ψ.real\nImΨ = Ψ.imag\n\n\ncuadros = []\nfor n in range(1,npts_t):\n    Ψ   = exp(-1J*ω*T[n])*exp(-1J*k*X)\n    cuadros.append( go.Frame(data=[go.Scatter(x=X, y=Ψ.real,mode=\"lines\",name=\"ReΨ\" ),\n                                   go.Scatter(x=X, y=Ψ.imag,mode=\"lines\",line=dict(color='firebrick'),name=\"ImΨ\" )],\n                             layout=go.Layout(title=f\"t={T[n]:.2f} (fs)\")) )\n\nfig = go.Figure(\n    data=[go.Scatter(x=X, y=ReΨ,mode=\"lines\",name=\"ReΨ\" ),go.Scatter(x=X, y=Ψ.imag,mode=\"lines\",line=dict(color='firebrick'),name=\"ImΨ\" )],\n    layout=go.Layout(\n        title=\"t=0.00 (fs)\",\n        xaxis_title=\"x (nm)\",\n        yaxis_title=\"Re[Ψ]\",\n        updatemenus=[dict(type=\"buttons\",\n                          x=0.5,y=1.0,\n                          buttons=[dict(label=\"Reproducir\",\n                                        method=\"animate\",\n                                        args=[None,\n                                        dict(frame=dict(duration=100,redraw=True),\n                                        transition=dict(duration=0,easing=None))] )])]\n                          \n    ),\n    frames = cuadros\n)\n\nfig.show()\n\n\nCaso. Un electrón con energía de 10 eV.\nk = 1.620e+10 (1/m)\nω = 1.519e+16 (1/s)",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Partícula libre en una dimensión</span>"
    ]
  },
  {
    "objectID": "2_1_molecula_H2.html",
    "href": "2_1_molecula_H2.html",
    "title": "Molécula \\(H_2\\)",
    "section": "",
    "text": "Code\n# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n\n1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n\nCode\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n\n\nCode\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n2 Variación de la geometría\n\n\nCode\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n3 Función que devuelve la energía\n\n\nCode\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n\n\nCode\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n\n\nCode\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\n\n\nCode\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\n\nText(0, 0.5, 'E [Ha]')\n\n\n\n\n\n\nSource: Abrir en colab"
  },
  {
    "objectID": "2_0_moleculaH2.html",
    "href": "2_0_moleculaH2.html",
    "title": "9  Molécula de Hidrógeno",
    "section": "",
    "text": "El Hamiltoniano de la molécula de hidrógeno es:\n\\[\n\\begin{align}\n\\hat{H}_{\\rm H_2} = \\frac{\\hat{P}}{2M_1}\n\\end{align}\n\\]",
    "crumbs": [
      "U2. Vibraciones",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Molécula de Hidrógeno</span>"
    ]
  },
  {
    "objectID": "2_2_vibra1d.html#relación-de-dispersión",
    "href": "2_2_vibra1d.html#relación-de-dispersión",
    "title": "11  Cadena Unidimensional",
    "section": "11.1 Relación de dispersión",
    "text": "11.1 Relación de dispersión\n\\[\n\\definecolor{azul}{RGB}{0, 0, 139}\n\\newcommand{\\kk}{\\textcolor{red}{k}}\n\\]\n\\[\n\\omega^2 = 2\\frac{\\kappa }{m}\\bigg[  1-\\cos(\\kk a ) \\bigg]\n\\]\nEntonces, \\[\n\\omega(k) = \\sqrt{\\frac{4\\kappa}{m}} \\bigg| \\sin\\bigg( \\frac{\\kk a}{2} \\bigg) \\bigg|\n\\]"
  },
  {
    "objectID": "2_2_vibra1d.html#desplazamientos-del-equilibrio",
    "href": "2_2_vibra1d.html#desplazamientos-del-equilibrio",
    "title": "11  Cadena Unidimensional",
    "section": "11.2 Desplazamientos del equilibrio",
    "text": "11.2 Desplazamientos del equilibrio\n\\[\nx_n = x_n^{\\rm eq} + A e^{i\\omega t-i\\kk x_n^{\\rm eq}}\n\\]\ndonde \\(x_n^{\\rm eq}=na\\).\n\\[\n\\delta x_n = A e^{i\\omega t-i\\kk na}\n\\]\n\n\n\n\n\n\n\\(k = 0.2\\pi/a\\)\n\n\n\n\n\n\n\nCode\nfrom pylab import *\n\nt   = 0; κ = 200; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = 0.2*pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,200,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()\n\n\nValor de k seleccionado: \nk = 0.628\nValor de ω seleccionado: \nω = 8.740\nPeriódo de oscilación: \nT = 8.740\n\n\n\n                                                \n\n\n\n\n\n\n\n\n\n\n\n\\(k = -0.2\\pi/a\\)\n\n\n\n\n\n\n\nCode\nfrom pylab import *\n\nt   = 0; κ = 200; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = -0.2*pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,200,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()\n\n\nValor de k seleccionado: \nk = -0.628\nValor de ω seleccionado: \nω = 8.740\nPeriódo de oscilación: \nT = 8.740\n\n\n\n                                                \n\n\n\n\n\n\n\n\n\n\n\n\\(k = \\pi/a\\)\n\n\n\n\n\n\n\nCode\nfrom pylab import *\n\nt   = 0; κ = 200; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,200,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()\n\n\nValor de k seleccionado: \nk = 3.142\nValor de ω seleccionado: \nω = 28.284\nPeriódo de oscilación: \nT = 28.284\n\n\n\n                                                \n\n\n\n\n\n\n\n\n\n\n\n\\(k = 0.2\\pi/a+2\\pi/a\\)\n\n\n\n\n\n\n\nCode\nfrom pylab import *\n\nt   = 0; κ = 200; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = 0.2*pi/a+2*pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,200,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()\n\n\nValor de k seleccionado: \nk = 6.912\nValor de ω seleccionado: \nω = 8.740\nPeriódo de oscilación: \nT = 8.740"
  },
  {
    "objectID": "2_3_eqnonda.html",
    "href": "2_3_eqnonda.html",
    "title": "12  Ecuación de onda",
    "section": "",
    "text": "La ecuación de onda es una ecuación diferencial parcial de segundo orden lineal y tiene la forma siguiente,\n\\[\n\\definecolor{purpura}{RGB}{160, 32, 240}\n\\newcommand{\\uu}{\\textcolor{purpura}{u}}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\nabla^2 \\uu\n\\tag{12.1}\\]\ndonde \\(v\\) es la rapidez de la onda y \\(\\uu\\) es una función de la posición y el tiempo, \\(\\uu = \\uu(\\vec{r},t)\\).\n\n\n\n\n\n\nEcuaciones de Maxwell\n\n\n\n\n\nEl campo eléctrico y el campo magnético siguen una ecuación de onda en el caso de que no haya cargas ni corrientes en el espacio\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{E} = c^2 \\nabla^2 \\vec{E} \\\\\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{B} = c^2 \\nabla^2 \\vec{B}\n\\]\n\n\n\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\tag{12.2}\\]\nConsideremos al espacio de forma discreta en el espacio\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h} \\approx \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h}\n\\]\nAlternativamente\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h} \\approx \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h}\n\\]\nEntonces la segunda derivada,\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} =\\lim_{h\\to 0} \\frac{\\frac{\\partial \\uu}{\\partial x}|_{x_0+h/2} - \\frac{\\partial \\uu}{\\partial x}|_{x_0-h/2} }{h}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} \\approx \\frac{u(x_0-h,t)-2u(x_0,t)+u(x_0+h,t)}{h}\n\\]"
  },
  {
    "objectID": "2_4_matrizdinamica.html#la-energía-potencial",
    "href": "2_4_matrizdinamica.html#la-energía-potencial",
    "title": "13  Matriz dinámica",
    "section": "13.1 La energía potencial",
    "text": "13.1 La energía potencial\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\vk}{\\vec{k}}\n\\newcommand{\\vRn}{\\vec{R}_{\\vn}}\n\\newcommand{\\vRm}{\\vec{R}_{\\vm}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ \\delta r_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}} = \\sum_{\\vm \\beta j} -U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]"
  },
  {
    "objectID": "2_4_matrizdinamica.html#ecuaciones-de-movimiento",
    "href": "2_4_matrizdinamica.html#ecuaciones-de-movimiento",
    "title": "13  Matriz dinámica",
    "section": "13.2 Ecuaciones de movimiento",
    "text": "13.2 Ecuaciones de movimiento\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} = -\\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\n\\[\nM_\\alpha \\frac{d^2}{dt^2} \\udes{\\vn}{\\alpha}{i} + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j} = 0\n\\]\nNotamos que tenemos \\(3rN\\) ecuaciones de movimiento, donde el \\(3\\) corresponde a las tres direcciones de movimiento en el espacio, \\(r\\) es el número de átomos en la celda unitaria y \\(N\\) son el número de celdas unitarias.\nProponemos una solución correspondiente a un modo normal, \\[\n\\udes{\\vn}{\\alpha}{i} = e^{i\\omega t-i\\vk\\cdot \\vRn }\\bigg[  \\frac{1}{\\sqrt{M}_\\alpha} u_{\\alpha i} \\bigg]\n\\]\nSustituimos en las ecuaciones de movimiento, \\[\n-\\omega^2 M_\\alpha \\bigg[  \\frac{1}{\\sqrt{M_\\alpha}} u_{\\alpha i} \\bigg] + \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) } \\frac{1}{\\sqrt{M}_\\beta} u_{\\beta j} = 0\n\\]\n\\[\n-\\omega^2 \\sqrt{M}_\\alpha u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M}_\\beta}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]\nNotamos que las ecuaciones anteriores son \\(3r\\) para cada celda unitaria \\(\\vn\\) y dado que todas las celdas son iguales, podemos elegir arbitrariamente \\(\\vn=\\vec{0}\\) y resolver. Entonces, dichas soluciones serán las mismas para todas.\n\\[\n-\\omega^2  u_{\\alpha i} + \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm }  \\bigg] u_{\\beta j} =0\n\\]\nLas \\(3r\\) ecuaciones podemos reescribirlas de forma matricial de la forma, \\[\n\\omega^2\\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right] =\n\\bigg[ \\frac{1}{\\sqrt{M_\\beta M_\\alpha}} \\sum_{\\vm} U_{\\vec{0} \\alpha i }^{\\vm \\beta j} e^{-i\\vk \\cdot  \\vRm } \\bigg]_{\\alpha i,\\beta j} \\left[\\begin{array}{c}\nu_{1 x}\\\\\nu_{1 y}\\\\\nu_{1 z}\\\\\n\\vdots \\\\\nu_{r x}\\\\\nu_{r y}\\\\\nu_{r z}\\\\\n\\end{array}\\right]\n\\]\ndonde la matriz del lado derecho se llama matriz dinámica.\n\\[\nD = \\left[\\begin{array}{cccc}\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 x }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\\ldots \\\\\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 y }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\n\\ldots \\\\\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 x} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 y} e^{-i\\vk \\cdot  \\vRm } &\n\\frac{1}{\\sqrt{M_1 M_1}} \\sum_{\\vm} U_{\\vec{0} 1 z }^{\\vm 1 z} e^{-i\\vk \\cdot  \\vRm } &\n\\ldots \\\\\n\\vdots&\\vdots&\\vdots&\\vdots\n\\end{array}\\right]\n\\]",
    "crumbs": [
      "U2. Vibraciones",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Matriz dinámica</span>"
    ]
  },
  {
    "objectID": "2_4_matrizdinamica.html#otra-notación",
    "href": "2_4_matrizdinamica.html#otra-notación",
    "title": "13  Matriz dinámica",
    "section": "13.3 Otra notación",
    "text": "13.3 Otra notación\nAlternativamente,\n\\[\n\\sum_{\\beta j } -\\omega^2 \\delta_{\\alpha \\beta}\\delta_{ij} u_{\\beta j}+ \\sum_{\\beta j } \\frac{1}{\\sqrt{M_\\beta M_\\alpha}}\\bigg[ \\sum_{\\vm} U_{\\vn \\alpha i }^{\\vm \\beta j} e^{ i\\vk \\cdot (\\vRn -\\vRm) }  \\bigg] u_{\\beta j} =0\n\\]",
    "crumbs": [
      "U2. Vibraciones",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Matriz dinámica</span>"
    ]
  },
  {
    "objectID": "2_5_calorespecifico.html",
    "href": "2_5_calorespecifico.html",
    "title": "14  Calor específico de los sólidos",
    "section": "",
    "text": "En 1819 Pierre Louis Dulong y Alexis Thérèse Petit establecieron que para casi todos los sólidos la capacidad calorífica esta dada por (ley de la Doulong-Petit),\n\\[\nC= 3 k_{\\rm B} \\text{ por átomo}\n\\]\n\\[\nC =3R\n\\]\ndonde \\(k_{\\rm B}=1.380649\\times 10^{-23} {\\rm J}\\cdot {\\rm K}^{-1}\\) es la constante de Boltzmann y \\(R=8.31446261815324 {\\rm J}\\cdot {\\rm K}^{-1}\\cdot {\\rm mol}^{-1}\\) es la constante molar de los gases.\nLa ly de Doulong-Petit es válida para temperatura ambiente.\n\n\n\nMaterial\nC/R\n\n\n\n\nAluminio (Al)\n2.91\n\n\nAntimonio (Sb)\n3.03\n\n\nCobre (Cu)\n2.94\n\n\nOro (Au)\n3.05\n\n\nPlata (Ag)\n2.99\n\n\nDiamante (C)\n0.735\n\n\n\nEn 1896 Boltzmann intento dar sentido a la Ley de Doulong Petit. Planteó, cada átomo del sólido esta ligado a otros átomos entonces cada átomo es un oscilador armónico. Es decir, su energía esta dada por \\(mv^2/2+kx^2/2\\) y utilizando el Teorema de equipartición de la energía, estableció que cada grado de libertad de oscilación contribuye en \\(k_{\\rm B}T\\) a la energía del sistema. En el caso de sólidos en tres dimensiones cada átomo contribuye a la energía en \\(3k_{\\rm B}T\\) por lo que\n\\[\nC=\\frac{d U}{d T } =3k_{\\rm B} \\text{ por átomo}\n\\]\n\n\nEn el caso de un gas, cada átomo contribuye a la energía en \\(mv_x^2/2+mv_y^2/2+mv_z^2/2\\) por lo que siguiendo el Teorema de Equipartición de la energía la capacidad calorífica por átomo es \\(C=3k_{\\rm B}/2\\).\nEn los inicios de los 1900, empezaron a realizar experimentos a bajas temperatura a algunos Kelvin. En 1907, Einstein intento explicar la capacidad calorífica a bajas temperaturas. Supuso que cada átomo es un oscilador armónico cuántico \\(E_n=\\hbar \\omega (n+1/2)\\).\nBoltzmann ya había establecido que la probabilidad de encontrar a un sistema a una energía \\(E_i\\) era \\[\n\\text{Probabilidad }\\propto e^{-\\beta E_i}=e^{-E_i/k_{\\rm B}T}\n\\]\nIntroduciendo la función de partición,\n\\[\nZ_{\\rm 1D} = \\sum_{n\\geq 0}  e^{-\\beta \\hbar \\omega (n+1/2)} = \\frac{e^{-\\beta \\hbar \\omega/2}}{1-e^{-\\beta \\hbar \\omega/2}}=\\frac{1}{2\\sinh (\\beta\\hbar\\omega/2)}\n\\]\n\n\nRecordemos que \\[\n\\sinh x=\\frac{e^x-e^{-x}}{2}\n\\]\npodemos calcular el valor medio de la energía\n\\[\n\\langle E \\rangle = -\\frac{1}{Z_{1D}} \\frac{\\partial Z_{1D}}{\\partial \\beta} =\\frac{\\hbar \\omega}{2} \\coth(\\beta \\hbar \\omega/2) = \\hbar \\omega \\bigg[ n_{\\rm B}(\\beta \\hbar \\omega) +\\frac{1}{2} \\bigg]\n\\]\ndonde \\[\nn_{\\rm B}(x)=\\frac{1}{e^x-1}\n\\]\nEntonces,\n\\[\nC = \\frac{\\partial \\langle E \\rangle}{\\partial T} = k_{\\rm B} (\\beta \\hbar \\omega)^2 \\frac{e^{\\beta \\omega}}{(e^{\\beta \\hbar \\omega}-1)^2}\n\\]\nEn el límite \\(T\\to \\infty\\)\n\\[\nC=k_{\\rm B} \\; \\Rightarrow \\; \\text{En tres dimensiones } C=3k_{\\rm B}\n\\]\nAún existía la problemática de bajas temperaturas el modelo de Einstein establece que \\(C\\sim e^{k_{\\rm B}T}\\) y experimentalmente se tenía que \\(C\\sim T^3\\).\nEn 1912, Debye desarrolla un modelo para determinar la cpacidad calorífica a bajas temperaturas. Las oscilaciones (osciladores armónicos) son similares a las del sonido (ondas sonoras). En las ondas sonoras \\[\n\\omega (k) = v| k|\n\\]\ndonde \\(v\\) es la rapidez del sonido.\nAnálogo a Einstein\n\\[\n\\langle E\\rangle = 3 \\sum_{\\vec{k}} \\hbar \\omega (\\vec{k}) \\bigg[ n_{\\rm B}(\\beta \\hbar \\omega) +1/2 \\bigg]\n\\]\nSustituimos que \\(\\omega (\\vec{k})=vk\\) y \\[\n\\sum_{k_x} \\to \\frac{L}{2\\pi} \\int dk_x\n\\]\n\\[\n\\langle E\\rangle = 3\\frac{L^3}{(2\\pi)^3} \\int d\\vec{k} \\Bigg\\{ \\hbar\\omega(\\vec{k}) \\bigg[  n_{\\rm B}(\\beta \\hbar \\omega) +1/2 \\bigg] \\Bigg\\}\n\\]\n\\[\n\\int d\\vec{k} \\to 4\\pi \\int_0^{\\infty} k^2 dk\n\\]\nUtilizando que \\(k=\\omega/v\\) entonces $dk=d$\n\\[\n\\langle E \\rangle = 3\\bigg(  \\frac{4\\pi L^3}{(2\\pi)^3} \\bigg) \\int_0^{\\omega_{\\rm corte}=\\omega_{\\rm D}} d\\omega \\Bigg\\{  \\omega^2\\frac{1}{v^3}\\hbar\\omega \\bigg[ n_{\\rm B} +1/2\\bigg] \\Bigg\\}\n\\]\n\\[\ng(\\omega) = L^3\\bigg[ \\frac{12\\pi \\omega^2}{(2\\pi^3)v^3} \\bigg]\n\\]\nUtilizando la función Zeta de Riemann a \\(T_{\\rm bajas}\\)\n\\[\n\\langle E \\rangle = 9 N \\frac{(k_{\\rm B}T)^4}{\\hbar \\omega_{\\rm D}} \\frac{\\pi^4}{15}\\,; \\; \\omega_{\\rm D} = 6\\pi^2 n v^3\n\\]\ndonde \\(n\\) es la densidad de átomos por unidad de volumen,\n\\[\n\\langle E \\rangle = \\frac{\\partial \\langle E \\rangle }{\\partial T } = Nk_{\\rm B} \\frac{k_{\\rm B}T^3}{(\\hbar \\omega_{\\rm D})^3} \\frac{12 \\pi^4}{5} \\sim T^3\n\\]\n\n\n\n\\(T_{\\rm Debye}\\,[{\\rm K}]\\)\nMateriales\n\n\n\n\n215\nAg\n\n\n315\nCu\n\n\n1000\nSi\n\n\n1850\nDiamante\n\n\n\nEn los sólidos el calor es transportador por fonones y electrones.\nCapacidad calorífica y conductividad térmica\nFlujo de energía térmica, \\(j_{U}\\),\n\\[\nj_{U}=-\\kappa \\frac{d T }{dx}\n\\]\ndonde \\[\n\\kappa = \\frac{1}{3} C v \\ell\n\\] es la conductividad térmica .\n\\[\nv \\sim \\frac{d\\omega}{dk}$\n\\]\n\\(v\\) es la rapidez de los fonones y \\(\\ell\\) camino libre medio de los fonones.",
    "crumbs": [
      "U2. Vibraciones",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Calor específico de los sólidos</span>"
    ]
  },
  {
    "objectID": "3_1_electroneslibres.html",
    "href": "3_1_electroneslibres.html",
    "title": "15  Electrones libres",
    "section": "",
    "text": "Los electrones en las capas\n\\[\n\\begin{align}\n    E_{\\rm sólido}=&\\left( {\\color{RoyalPurple}\\begin{array}{c}\n         \\text{Energía}  \\\\\n         \\text{cinética} \\\\\n         \\text{núcleos}\n    \\end{array}} \\right)+ \\left( {\\color{Orange} \\begin{array}{c}\n         \\text{Energía}  \\\\\n         \\text{cinética} \\\\\n         \\text{electrones}\n    \\end{array}} \\right) + \\left( {\\color{Fuchsia}\\begin{array}{c}\n         \\text{Energía}  \\\\\n         \\text{potencial} \\\\\n         \\text{electrostática} \\\\\n         \\text{núcleo-núcleo}\n    \\end{array}} \\right) \\nonumber\\\\\n    +& \\left( {\\color{Maroon}\\begin{array}{c}\n         \\text{Energía}  \\\\\n         \\text{potencial} \\\\\n         \\text{electrostática} \\\\\n         \\text{electrón-electrón}\n    \\end{array} } \\right)\n    + \\left( {\\color{PineGreen}\\begin{array}{c}\n         \\text{Energía}  \\\\\n         \\text{potencial} \\\\\n         \\text{electrostática} \\\\\n         \\text{núcleo-electrón}\n    \\end{array} }\\right)\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\hat{H}_{\\rm sólido} =& \\left( {\\color{RoyalPurple}-\\frac{\\hbar}{2}\\sum_\\alpha \\frac{1}{m_\\alpha} \\nabla_\\alpha^2 } \\right)+ \\left( {\\color{Orange} -\\frac{\\hbar^2}{2m_e} \\sum_i \\nabla_i^2} \\right) \\nonumber\\\\\n+& \\left( {\\color{Fuchsia} \\sum_\\alpha \\sum_\\beta \\frac{Z_\\alpha Z_\\beta e^2}{4\\pi\\varepsilon_0 r_{\\alpha\\beta}} } \\right) - \\left( {\\color{PineGreen} \\sum_\\alpha \\sum_i \\frac{Z_\\alpha e^2}{4\\pi\\epsilon_0 r_{i\\alpha}}  }\\right) \\nonumber\\\\\n    +& \\left( {\\color{Maroon} \\sum_{j}\\sum_{i&gt;j} \\frac{e^2}{4\\pi\\varepsilon_0 r_{ij}} } \\right)\n\\end{align}\n\\]\ndonde \\(\\alpha\\) y \\(\\beta\\) son índices para los núcleos, e \\(i\\) y \\(j\\) son índices para los electrones. \\(Z_\\alpha\\) y \\(Z_\\beta\\) es el número atómico de los átomos. \\(m_\\alpha\\) y \\(m_e\\) son las masas del núcleo y del electrón, respectivamente.",
    "crumbs": [
      "U3. Electrones",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Electrones libres</span>"
    ]
  },
  {
    "objectID": "1_7_fourier.html",
    "href": "1_7_fourier.html",
    "title": "7  Análisis de Fourier",
    "section": "",
    "text": "7.1 Serie de Fourier\n\\[\n\\definecolor{magenta}{RGB}{255,0,144}\n\\newcommand{\\cparentesis}[1]{ {\\color{magenta} #1} }\n\\newcommand{\\iprn}{\\cparentesis{(}}\n\\newcommand{\\fprn}{\\cparentesis{)}}\n\\newcommand{\\ii}{{\\rm i}}\n\\]\nEl objetivo de la presente sección es generar una intuición de la siguiente afirmación: &gt; La red recíproca es la transformada de Fourier de la red real.\nDefinimos la suma de Fourier, \\(s_{N}\\), como la serie truncada hasta el término \\(N\\) de la siguiente forma:\n\\[\n\\begin{equation*}\ns_{N}=\\frac{a_0}{2} + \\sum_{n=1}^{N} \\left[ a_n \\cos \\left( \\frac{2n\\pi}{L}x \\right) + b_n \\sin \\left( \\frac{2n\\pi}{L}x \\right) \\right] \\approx f(x)\n\\end{equation*}\n\\]",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Análisis de Fourier</span>"
    ]
  },
  {
    "objectID": "1_1_red.html",
    "href": "1_1_red.html",
    "title": "1  Red",
    "section": "",
    "text": "1.1 En 1D\nMostrar código\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud del vector a1\na1 = 0.6\n# Definimos el vector vec_a1\nvec_a1 = array([a1])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4]\nn1 = arange( -4, 5 )\n# Obtenemos los puntos de la red\nred = dot( n1.reshape(len(n1),1),vec_a1 )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((4,2)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red, zeros_like(red), label=f\"$a_1={a1}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Colocamos el cuadro de leyenda\nax.legend()\n# Colocamos las marcas en el eje x acorde a los puntos de la red\nax.set_xticks(red)\n# Colocamos unas líneas punteadas como guía\nax.grid(ls='--')\n# Colocamos las marcas en el eje y\nax.set_yticks([0])\n# Colocamos el texto en las marcas del eje y\nax.set_yticklabels([\"\"])\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1.1: Ejemplo de red unidimensional",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Red</span>"
    ]
  },
  {
    "objectID": "2_4_matrizdinamica.html",
    "href": "2_4_matrizdinamica.html",
    "title": "13  Matriz dinámica",
    "section": "",
    "text": "13.1 La energía potencial\nObjetivo: describir de forma general cómo se mueven los átomos en un sólido\nLa estrategía general es: determinar la energía potencial, derivar las ecuaciones de movimiento y resolver las ecuaciones de movimiento buscando los modos normales.\n\\[\n\\newcommand{\\vn}{\\vec{n}}\n\\newcommand{\\vm}{\\vec{m}}\n\\newcommand{\\vk}{\\vec{k}}\n\\newcommand{\\vRn}{\\vec{R}_{\\vn}}\n\\newcommand{\\vRm}{\\vec{R}_{\\vm}}\n\\newcommand{\\req}[3]{ r_{#1 #2 #3}}\n\\newcommand{\\udes}[3]{ \\delta r_{#1 #2 #3}}\n\\]\n\\[\n\\begin{align}\nU &= U(\\{ \\text{posiciones: } \\req{\\vn}{\\alpha}{i} + \\udes{\\vn}{\\alpha}{i} \\}) \\\\\n&\\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\})+ \\sum_{\\vn \\alpha i} \\frac{\\partial U}{\\partial \\udes{\\vn}{\\alpha}{i}}\\bigg|_{\\req{\\vn}{\\alpha}{i}} \\udes{\\vn}{\\alpha}{i} + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} \\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nIntroducimos la siguiente notación para las segundas derivadas,\n\\[\n\\frac{\\partial^2 U}{\\partial \\udes{\\vn}{\\alpha}{i} \\partial \\udes{\\vm}{\\beta}{j} }\\bigg|_{ \\req{\\vn}{\\alpha}{i} } = U_{\\vn \\alpha i }^{\\vm \\beta j}\\,,\n\\] las cuales llamaremos constantes de acoplamiento. Entonces, la aproximación para la energía potencial es\n\\[\n\\begin{align}\nU \\approx U(\\{  \\req{\\vn}{\\alpha}{i} \\}) + \\frac{1}{2} \\sum_{\\vn \\alpha i } \\sum_{\\vm \\beta j} U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vn}{\\alpha}{i} \\udes{\\vm}{\\beta}{j}\n\\end{align}\n\\]\nLa fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) es,\n\\[\nF_{\\vn \\alpha i }= -\\frac{\\partial U}{\\partial  \\udes{\\vn}{\\alpha}{i}} = \\sum_{\\vm \\beta j} -U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\n\\]\nNotamos que,\n\\[\n-U_{\\vn \\alpha i }^{\\vm \\beta j} \\udes{\\vm}{\\beta}{j}\\,,\n\\] es la fuerza que se realiza sobre el átomo \\(\\alpha\\) en la celda \\(\\vn\\) en la dirección \\(i\\) al desplazar del equilibrio el átomo \\(\\beta\\) en la celda \\(\\vm\\) en la dirección \\(j\\), \\(\\udes{\\vm}{\\beta}{j}\\).\nDada la simetría de traslación \\(U_{\\vn \\alpha i }^{\\vm \\beta j}\\) sólo depende de la diferencia de las celdas; es decir, de \\(\\vm-\\vn\\). Entonces, \\[\nU_{\\vec{0}\\alpha i}^{ (\\vm-\\vn)\\beta j } = U_{\\vn \\alpha i }^{\\vm \\beta j}\n\\]",
    "crumbs": [
      "U2. Vibraciones",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Matriz dinámica</span>"
    ]
  },
  {
    "objectID": "1_8_particulalibre.html",
    "href": "1_8_particulalibre.html",
    "title": "8  Partícula libre en una dimensión",
    "section": "",
    "text": "8.1 Visualización de la solución\n\\[\n\\definecolor{magenta}{RGB}{255,0,144}\n\\newcommand{\\cparentesis}[1]{ {\\color{magenta} #1} }\n\\newcommand{\\iprn}{\\cparentesis{(}}\n\\newcommand{\\fprn}{\\cparentesis{)}}\n\\newcommand{\\ii}{{\\rm i}}\n\\]\nLa solución de la partícula libre en mecánica cuántica está dada por, \\[\n\\psi\\iprn x \\fprn = c_1 e^{ {\\rm i}\\sqrt{ \\frac{2mE}{\\hbar^2} } x }+ c_2 e^{ -{\\rm i}\\sqrt{ \\frac{2mE}{\\hbar^2} } x }\n\\]\nResulta útil definir \\(k \\equiv \\sqrt{\\frac{2mE}{\\hbar^2}}\\), que nos permite reescribir la solución general de la forma\n\\[\n\\psi\\iprn x \\fprn = c_1 e^{ {\\rm i}k x }+ c_2 e^{ -{\\rm i} k x }\n\\]\nLas constantes \\(c_1\\) y \\(c_2\\) son arbitrarias y si intentamos evaluar la integral \\[\n\\int_{-\\infty}^{\\infty}  \\psi^*\\iprn x \\fprn \\psi\\iprn x \\fprn dx \\to \\infty\n\\] Es decir, la solución de la partícula libre no es normalizable en el sentido usual. Este resultado es razonable, ya que no hay razón por la cual la probabilidad de encontrar a la partícula libre cuando \\(x\\to \\pm \\infty\\) tienda a cero.",
    "crumbs": [
      "U1. Estructuras periódicas",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Partícula libre en una dimensión</span>"
    ]
  }
]