[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PFS",
    "section": "",
    "text": "En el sitio se encuentran una selección de notas del curso de Propiedades de Física de los Sólidos (clave: 0087) de la Facultad de Química, UNAM."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "2  Acerca de",
    "section": "",
    "text": "Acerca del sitio"
  },
  {
    "objectID": "vibra1d.html",
    "href": "vibra1d.html",
    "title": "4  Cadena Unidimensional",
    "section": "",
    "text": "from pylab import *\n\nt   = 0; κ = 1; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk1   = 0.2*pi/a\nk2   = 0.5*pi/a+2*pi/a\n#######\nω1   = sqrt(4*κ/m) * abs( sin(k1*a/2) )\nω2   = sqrt(4*κ/m) * abs( sin(k2*a/2) )\nu1   = A*exp(1J*ω1*t-1J*k1*n*a) # En lugar de δx_n\nu2   = A*exp(1J*ω2*t-1J*k2*n*a) # En lugar de δx_n\ny1   = zeros(len(xeq)) + u1\ny2   = zeros(len(xeq)) + u2\nx    = xeq # + u # δx\nprint(f\"k = {k1:.3f}, {k2:.3f}\")\nprint(f\"ω = {ω1:.3f}, {ω2:.3f}\")\n\nk = 0.628, 7.854\nω = 0.618, 1.414\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω1 # periodo\nveces  = 4       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nx0  = xeq\nu10 = A*exp(1J*ω1*t0-1J*k1*n*a)\ny10 = zeros(len(xeq)) + u10\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    u1 = A*exp(1J*ω1*t-1J*k1*n*a)\n    u2 = A*exp(1J*ω2*t-1J*k2*n*a)\n    y1 = zeros(len(xeq)) + u1\n    y2 = zeros(len(xeq)) + u2\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x,\n                                              y=y1.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0, \n                       y=y10.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=5,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  },
  {
    "objectID": "pyscf_H2.html",
    "href": "pyscf_H2.html",
    "title": "3  Molécula \\(H_2\\)",
    "section": "",
    "text": "# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n4 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n5 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n6 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "pyscf_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "3.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "pyscf_H2.html#variación-de-la-geometría",
    "href": "pyscf_H2.html#variación-de-la-geometría",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.2 Variación de la geometría",
    "text": "3.2 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "pyscf_H2.html#función-que-devuelve-la-energía",
    "href": "pyscf_H2.html#función-que-devuelve-la-energía",
    "title": "3  Molécula \\(H_2\\)",
    "section": "3.3 Función que devuelve la energía",
    "text": "3.3 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "molecula_H2.html",
    "href": "molecula_H2.html",
    "title": "Molécula \\(H_2\\)",
    "section": "",
    "text": "# Importación de las librerías\n#---\nfrom pylab import * # Librerías numpy,scipy y matplotlib\nimport pyscf        # Librería pyscf\nfrom pyscf import scf\n\n\n1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405\n\n\n\n\n2 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591\n\n\n\n\n3 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')\n\n\n\n\n\n\nSource: Abrir en colab"
  },
  {
    "objectID": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "href": "molecula_H2.html#geometría-de-la-molécula-diatómica-rm-h_2",
    "title": "Molécula \\(H_2\\)",
    "section": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)",
    "text": "0.1 Geometría de la molécula diatómica \\({\\rm H}_2\\)\n\n\n\nÁtomo\nX[Å]\nY[Å]\nZ[Å]\n\n\n\n\nH\n0.0000\n0.0000\n0.0000\n\n\nH\n0.0000\n0.0000\n0.7414\n\n\n\n\n# Definición de la clase mole (molecule)\n# útil para manipular los parámetros \n# y atributos de las integrales GTO.\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 0.7414 \n    \"\"\",basis = \"STO-3G\")\n# ¿Qué significa base STO-3G?\n\n# Define la molécula con la geometría \n# y ahora puede calcularse la Energía\nH2 = H2.build()\n\n\n# Define el método de cálculo con la geometría\nrhf = scf.RHF(H2)\n# ¿Qué significa RHF?\n# Restricted Hartree Fock\n\n# Ejecuta el método definido y regresa la \n# Energía convergida.\nrhf.kernel(print=False)\n\n# Las unidades de la energia son Hartree\n# 1 Hartree = 27.211 eV\n\n# Los Hartree son las unidades atomicas de la energia\n\nconverged SCF energy = -1.11668438708534\n\n\n-1.1166843870853405"
  },
  {
    "objectID": "molecula_H2.html#variación-de-la-geometría",
    "href": "molecula_H2.html#variación-de-la-geometría",
    "title": "Molécula \\(H_2\\)",
    "section": "1.1 Variación de la geometría",
    "text": "1.1 Variación de la geometría\n\nd = 3.0 # angstroms\nH2 = pyscf.gto.Mole(atom = \"\"\"\n    H 0.0000  0.0000 0.0000\n    H 0.0000  0.0000 {0:.4f} \n    \"\"\".format(d),basis = \"STO-3G\")\nH2  = H2.build()\nrhf = scf.RHF(H2)\nrhf.kernel()\n\nconverged SCF energy = -0.656048251145591\n\n\n-0.656048251145591"
  },
  {
    "objectID": "molecula_H2.html#función-que-devuelve-la-energía",
    "href": "molecula_H2.html#función-que-devuelve-la-energía",
    "title": "Molécula \\(H_2\\)",
    "section": "1.2 Función que devuelve la energía",
    "text": "1.2 Función que devuelve la energía\n\ndef SCFenergia(d=0.7414):\n  H2 = pyscf.gto.Mole(atom = \"\"\"\n      H 0.0000  0.0000 0.0000\n      H 0.0000  0.0000 {0:.4f} \n      \"\"\".format(d),basis = \"STO-3G\")\n  H2  = H2.build()\n  rhf = scf.RHF(H2)\n  rhf.verbose = 0 \n  SCFe = rhf.kernel()\n  return SCFe\n\n\n# Separación entre átomos de H\nd = linspace(0.4,3.0,301) # angstroms\n\n\n# Evaluación de la Energía\nE = list( map(SCFenergia,d))\n\n\nplot(d,E,'o-')\nxlabel('d [Å]')\nylabel('E [Ha]')\n\nText(0, 0.5, 'E [Ha]')"
  },
  {
    "objectID": "eqnonda.html",
    "href": "eqnonda.html",
    "title": "5  Ecuación de onda",
    "section": "",
    "text": "La ecuación de onda es una ecuación diferencial parcial de segundo orden lineal y tiene la forma siguiente,\n\\[\n\\definecolor{purpura}{RGB}{160, 32, 240}\n\\newcommand{\\uu}{\\textcolor{purpura}{u}}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\nabla^2 \\uu\n\\tag{5.1}\\]\ndonde \\(v\\) es la rapidez de la onda y \\(\\uu\\) es una función de la posición y el tiempo, \\(\\uu = \\uu(\\vec{r},t)\\).\n\n\n\n\n\n\nEcuaciones de Maxwell\n\n\n\n\n\nEl campo eléctrico y el campo magnético siguen una ecuación de onda en el caso de que no haya cargas ni corrientes en el espacio\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{E} = c^2 \\nabla^2 \\vec{E} \\\\\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial t^2} \\vec{B} = c^2 \\nabla^2 \\vec{B}\n\\]\n\n\n\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\tag{5.2}\\]\nConsideremos al espacio de forma discreta en el espacio\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h} \\approx \\frac{\\uu(x_0+h,t)-\\uu(x_0,t)}{h}\n\\]\nAlternativamente\n\\[\n\\frac{\\partial }{\\partial x} \\uu \\bigg|_{x_0} = \\lim_{h\\to 0} \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h} \\approx \\frac{\\uu(x_0+h/2,t)-\\uu(x_0-h/2,t)}{h}\n\\]\nEntonces la segunda derivada,\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} =\\lim_{h\\to 0} \\frac{\\frac{\\partial \\uu}{\\partial x}|_{x_0+h/2} - \\frac{\\partial \\uu}{\\partial x}|_{x_0-h/2} }{h}\n\\]\n\\[\n\\frac{\\partial^2 }{\\partial x^2} \\uu \\bigg|_{x_0} \\approx \\frac{u(x_0-h,t)-2u(x_0,t)+u(x_0+h,t)}{h}\n\\]"
  },
  {
    "objectID": "eqnonda.html#ejemplo",
    "href": "eqnonda.html#ejemplo",
    "title": "5  Ecuación de onda",
    "section": "5.1 Ejemplo",
    "text": "5.1 Ejemplo\nPosiblemente reconozca\n:::\nEn el caso de una dimensión, \\(\\uu=\\uu(x,t)\\) y cumple la ecuación, \\[\n\\begin{align}\n\\frac{\\partial^2 }{\\partial t^2} \\uu = v^2 \\frac{\\partial^2 }{\\partial t^2} \\uu\n\\end{align}\n\\tag{5.2}\\]"
  },
  {
    "objectID": "vibra1d.html#relación-de-dispersión",
    "href": "vibra1d.html#relación-de-dispersión",
    "title": "4  Cadena Unidimensional",
    "section": "4.1 Relación de dispersión",
    "text": "4.1 Relación de dispersión\n\\[\n\\definecolor{azul}{RGB}{0, 0, 139}\n\\newcommand{\\kk}{\\textcolor{red}{k}}\n\\]\n\\[\n\\omega^2 = 2\\frac{\\kappa }{m}\\bigg[  1-\\cos(\\kk a ) \\bigg]\n\\]\nEntonces, \\[\n\\omega(k) = \\sqrt{\\frac{4\\kappa}{m}} \\bigg| \\sin\\bigg( \\frac{\\kk a}{2} \\bigg) \\bigg|\n\\]"
  },
  {
    "objectID": "vibra1d.html#desplazamientos-del-equilibrio",
    "href": "vibra1d.html#desplazamientos-del-equilibrio",
    "title": "4  Cadena Unidimensional",
    "section": "4.2 Desplazamientos del equilibrio",
    "text": "4.2 Desplazamientos del equilibrio\n\\[\nx_n = x_n^{\\rm eq} + A e^{i\\omega t-i\\kk x_n^{\\rm eq}}\n\\]\ndonde \\(x_n^{\\rm eq}=na\\).\n\\[\n\\delta x_n = A e^{i\\omega t-i\\kk na}\n\\]\n\nfrom pylab import *\n\nt   = 0; κ = 100; m = 1; a = 1; A = 0.2\nnmx = 10 \nn   = arange(-nmx,nmx)\nxeq = n*a\nyeq = zeros_like(xeq)\n#######\nk    = 0.2*pi/a\n#######\nω    = sqrt(4*κ/m) * abs( sin(k*a/2) )\nδx   = A*exp(1J*ω*t-1J*k*n*a) # En lugar de δx_n\nx    = xeq + δx\ny    = zeros(len(xeq)) # + δx\nprint(\"Valor de k seleccionado: \")\nprint(f\"k = {k:.3f}\")\nprint(\"Valor de ω seleccionado: \")\nprint(f\"ω = {ω:.3f}\")\nprint(\"Periódo de oscilación: \")\n\nT = 2*pi/ω\nprint(f\"T = {ω:.3f}\")\n\nValor de k seleccionado: \nk = 0.628\nValor de ω seleccionado: \nω = 6.180\nPeriódo de oscilación: \nT = 6.180\n\n\n\n\nCode\n# Librería de graficación con plotly.\nimport plotly.graph_objects as go\n\n\nT      = 2*pi/ω   # periodo\nveces  = 10       # número de periodos\n\n# Posición en el tiempo cero\nt0  = 0\nδx0 = A*exp(1J*ω*t0-1J*k*n*a)\nx0  = xeq \ny0  = zeros(len(xeq)) + δx0\n\n\ntime   = linspace(t0,veces*T,endpoint=False)\n\n\nFrames = []\nfor t in time:\n    δx = A*exp(1J*ω*t-1J*k*n*a)\n    y  = zeros(len(xeq)) + δx\n    x  = xeq # + u # + δx\n    Frames.append( go.Frame(data=[ go.Scatter(x=x.real,\n                                              y=y.real,\n                                              mode=\"markers\",\n                                              marker=dict(color=\"red\",size=10),\n                                              name=f'time = {t:.2f}') ]) )\n\n\nfig = go.Figure(\n    data = [go.Scatter(x=x0.real, \n                       y=y0.real,\n                       mode=\"markers\",\n                       marker=dict(color=\"red\",size=10),\n                       name=f'time = {t0:.2f}')],\n    layout = go.Layout(xaxis=dict(range=[-nmx-1, nmx+1], autorange=False),\n                       yaxis=dict(range=[-0.5, 0.5], autorange=False),\n                       showlegend=True,\n                       title=\"Start Title\",\n                       updatemenus=[dict(type    = \"buttons\",\n                                         direction = \"right\",\n                                         buttons = [dict(label=\"Play\",\n                                                         method  = \"animate\",\n                                                         args    = [None,\n                                                                    dict(frame       = dict(duration=50,redraw=True), \n                                                                         transition  = dict(duration=4),\n                                                                         fromcurrent = True,\n                                                                         mode        = 'immediate')])])]),\n    frames = Frames\n)\n\nfig.show()"
  }
]