{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Red\n",
        "\n",
        ":::{.justify}\n",
        "En general, los sólidos se forman de átomos densamente empaquetados, en especial, estaremos interesados cuando los átomos formen arreglos con simetría traslacional que llamaremos estructuras periódicas o estructuras cristalinas (de forma breve también los llamaremos cristales). Las estructuras periódicas se caracterizan por la combinación de una red y un decorado.\n",
        ":::\n",
        "\n",
        "::: {.callout-note appearance=\"simple\" icon=false collapse=\"false\"}\n",
        "## Red (definición)\n",
        "\n",
        "Una red es el conjunto infinito de puntos definidos por la suma con coeficientes enteros de un conjunto de vectores de red linealmente independientes.\n",
        "\n",
        "$$\n",
        "\\text{En 1D: }\\quad \\bigg\\{ \\vec{R}_{(n1)} = n_1\\vec{a}_1 \\;\\bigg|\\; n_1\\in \\mathbb{Z}\\bigg\\}\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\text{En 2D: }\\quad \\bigg\\{ \\vec{R}_{(n1,n2)} = n_1\\vec{a}_1 +n_2\\vec{a}_2 \\;\\bigg|\\; n_1,n_2 \\in \\mathbb{Z}\\bigg\\}\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\text{En 3D: }\\quad \\bigg\\{ \\vec{R}_{(n1,n2,n3)} = n_1\\vec{a}_1 +n_2\\vec{a}_2+n_3\\vec{a_3} \\;\\bigg|\\; n_1,n_2,n_3 \\in \\mathbb{Z}\\bigg\\}\n",
        "$$\n",
        "\n",
        ":::\n",
        "\n",
        "## En 1D\n"
      ],
      "id": "311c4938"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-red1d\n",
        "#| fig-cap: Ejemplo de red unidimensional\n",
        "\n",
        "# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\n",
        "from pylab import * \n",
        "\n",
        "# Definimos la magnitud del vector a1\n",
        "a1 = 0.6\n",
        "# Definimos el vector vec_a1\n",
        "vec_a1 = array([a1])\n",
        "# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4]\n",
        "n1 = arange( -4, 5 )\n",
        "# Obtenemos los puntos de la red\n",
        "red = dot( n1.reshape(len(n1),1),vec_a1 )\n",
        "\n",
        "# Graficamos \n",
        "# Definimos una figura -> fig y sus ejes -> ax\n",
        "fig,ax = plt.subplots(figsize=((4,2)))\n",
        "\n",
        "# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n",
        "# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n",
        "# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\n",
        "ax.scatter(red, zeros_like(red), label=f\"$a_1={a1}$\")\n",
        "# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n",
        "\n",
        "# Colocamos el cuadro de leyenda\n",
        "ax.legend()\n",
        "# Colocamos las marcas en el eje x acorde a los puntos de la red\n",
        "ax.set_xticks(red)\n",
        "# Colocamos unas líneas punteadas como guía\n",
        "ax.grid(ls='--')\n",
        "# Colocamos las marcas en el eje y\n",
        "ax.set_yticks([0])\n",
        "# Colocamos el texto en las marcas del eje y\n",
        "ax.set_yticklabels([\"\"])\n",
        "\n",
        "# Mostramos la gráfica\n",
        "plt.show()"
      ],
      "id": "fig-red1d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## En 2D\n"
      ],
      "id": "932e069b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-red2d\n",
        "#| fig-cap: Ejemplo de red bidimensional\n",
        "\n",
        "# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\n",
        "from pylab import * \n",
        "\n",
        "# Definimos la magnitud de los vectores, a1 y a2\n",
        "a1 = 1.0\n",
        "a2 = 1.0\n",
        "# Definimos el vector vec_a1\n",
        "vec_a1 = array([       a1,         0])\n",
        "# Definimos el vector vec_a2 con una rotación de un ángulo θ\n",
        "θ = radians(60)\n",
        "vec_a2 = array([a2*cos(θ), a2*sin(θ)])\n",
        "# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n",
        "# tanto para n1 como n2\n",
        "n1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n",
        "# Con el fin de realizar las diferentes combinaciones lineales nos será \n",
        "# útil tener los coeficiente como un arreglo en una dimensión\n",
        "n1 = n1.flatten()\n",
        "n2 = n2.flatten()\n",
        "# Colocamos los vectores en una matriz, donde cada renglón es un vector\n",
        "A = array( [vec_a1,vec_a2] )\n",
        "# Colocamos los coeficientes en una matriz\n",
        "coefs = column_stack((n1,n2))\n",
        "# Obtenemos los puntos de la red al multiplicar ambas matrices\n",
        "red = dot( coefs,A )\n",
        "\n",
        "# Graficamos \n",
        "# Definimos una figura -> fig y sus ejes -> ax\n",
        "fig,ax = plt.subplots(figsize=((6,6)))\n",
        "\n",
        "# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n",
        "# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n",
        "# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\n",
        "ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n",
        "# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n",
        "\n",
        "# Graficamos los vectores de red\n",
        "ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n",
        "ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n",
        "\n",
        "# Colocamos el cuadro de leyenda\n",
        "ax.legend()\n",
        "\n",
        "ax.set_aspect('equal')\n",
        "\n",
        "# Mostramos la gráfica\n",
        "plt.show()"
      ],
      "id": "fig-red2d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## En 3D"
      ],
      "id": "bb72289e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: fig-red3d\n",
        "#| fig-cap: Ejemplo de red tridimensional\n",
        "\n",
        "a1,a2,a3 = 1,1,3\n",
        "vec_a1 = array([a1,0,0])\n",
        "θ = radians(120)\n",
        "vec_a2 = array([a2*cos(θ), a2*sin(θ),0])\n",
        "vec_a3 = array([0,0,a3])\n",
        "A = array( [vec_a1,vec_a2,vec_a3] )\n",
        "n1,n2,n3 = mgrid[ -2:2:5J,-2:2:5J,-1:1:3J ]\n",
        "n1 = n1.flatten()\n",
        "n2 = n2.flatten()\n",
        "n3 = n3.flatten()\n",
        "coefs = column_stack((n1,n2,n3))\n",
        "\n",
        "red = dot(coefs,A)\n",
        "\n",
        "import plotly.graph_objects as go\n",
        "\n",
        "def GraficaVector(a,vec_a,Color,label):\n",
        "    Tip    = 0.5\n",
        "    ColorP = Color\n",
        "    P      = vec_a\n",
        "    # Dirección de los vectores\n",
        "    Punit  = P/sqrt(dot(P,P))\n",
        "    # Vector P\n",
        "    TipP = go.Cone(x=[P[0]],y=[P[1]],z=[P[2]],\n",
        "                u=[Tip*Punit[0]],v=[Tip*Punit[1]],w=[Tip*Punit[2]],\n",
        "                colorscale=[[0, ColorP],[1.0, ColorP]],\n",
        "                sizemode=\"absolute\",\n",
        "                sizeref=Tip,\n",
        "                anchor=\"tip\",\n",
        "                showscale=False)\n",
        "    VecP = go.Scatter3d(x=[0,P[0]-Tip*Punit[0]],\n",
        "                        y=[0,P[1]-Tip*Punit[1]],\n",
        "                        z=[0,P[2]-Tip*Punit[2]],\n",
        "                        mode=\"lines\",name=label,\n",
        "                        line=dict(width=10,color=ColorP))\n",
        "    return TipP,VecP\n",
        "\n",
        "Tipa1,Veca1 = GraficaVector(a1,vec_a1,'rgba(0, 191, 255, 60)',\"a1\")\n",
        "Tipa2,Veca2 = GraficaVector(a2,vec_a2,'rgba(233,150,122, 60)',\"a2\")\n",
        "Tipa3,Veca3 = GraficaVector(a3,vec_a3,'rgba( 50,205, 50, 60)',\"a2\")\n",
        "\n",
        "PLOTS = [go.Scatter3d(x=red.T[0], y=red.T[1], z=red.T[2], mode='markers',marker=dict(size=6),name=\"red\"),Tipa1,Veca1,Tipa2,Veca2,Tipa3,Veca3]\n",
        "\n",
        "fig = go.Figure(data=PLOTS)\n",
        "fig.show()"
      ],
      "id": "fig-red3d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.callout-note appearance=\"simple\" icon=false collapse=\"false\"}\n",
        "## Red (definición equivalente)\n",
        "Una red es un conjunto de puntos donde el entorno de cualquier punto es quivalente al entorno de cualquier otro.\n",
        ":::\n"
      ],
      "id": "852a7209"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}